<!DOCTYPE html>
<!-- this file is auto-generated from threejs/lessons/kr/threejs-custom-buffergeometry.md. Do not edited directly -->
<!--
Copyright 2018, Google Inc.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of Google Inc. nor the names of their
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ko">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="사용자 지정 BufferGeometry를 만드는 법에 대해 알아봅니다" />
<meta name="keywords" content="webgl graphics three.js" />
<meta name="thumbnail" content="https://threejsfundamentals.org/threejs/lessons/screenshots/threejs-custom-buffergeometry_ko.jpg" />

<meta property="og:title" content="Three.js 사용자 지정 BufferGeometry" />
<meta property="og:type" content="website" />
<meta property="og:image" content="https://threejsfundamentals.org/threejs/lessons/screenshots/threejs-custom-buffergeometry_ko.jpg" />
<meta property="og:description" content="사용자 지정 BufferGeometry를 만드는 법에 대해 알아봅니다" />
<meta property="og:url" content="https://threejsfundamentals.org/threejs/lessons/kr/threejs-custom-buffergeometry.html" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site" content="@greggman" />
<meta name="twitter:creator" content="@greggman" />
<meta name="twitter:domain" content="threejsfundamentals.org" />
<meta name="twitter:title" content="Three.js 사용자 지정 BufferGeometry" />
<meta name="twitter:url" content="https://threejsfundamentals.org/threejs/lessons/kr/threejs-custom-buffergeometry.html" />
<meta name="twitter:description" content="사용자 지정 BufferGeometry를 만드는 법에 대해 알아봅니다" />
<meta name="twitter:image:src" content="https://threejsfundamentals.org/threejs/lessons/screenshots/threejs-custom-buffergeometry_ko.jpg" />

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://threejsfundamentals.org/#website",
      "url":"https://threejsfundamentals.org/",
      "name":"ThreejsFundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://threejsfundamentals.org/threejs/lessons/kr/threejs-custom-buffergeometry.html#primaryimage",
      "url":"https://threejsfundamentals.org/threejs/lessons/screenshots/threejs-custom-buffergeometry_ko.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://threejsfundamentals.org/threejs/lessons/kr/threejs-custom-buffergeometry.html#webpage",
      "url":"https://threejsfundamentals.org/threejs/lessons/kr/threejs-custom-buffergeometry.html",
      "inLanguage":"ko",
      "name":"Three.js 사용자 지정 BufferGeometry",
      "keywords":"webgl graphics three.js programming",
      "isPartOf":{
        "@id":"https://threejsfundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://threejsfundamentals.org/threejs/lessons/kr/threejs-custom-buffergeometry.html#primaryimage"
      }
    }
  ]
}
</script>

<title>Three.js 사용자 지정 BufferGeometry</title>
<link href="/threejs/lessons/resources/threejsfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/threejs/lessons/resources/threejsfundamentals-icon.png">
<link rel="icon" href="/threejs/lessons/resources/threejsfundamentals-icon.png">

<link rel="stylesheet" href="/threejs/lessons/lang.css" />
<link rel="stylesheet" href="/threejs/lessons/kr/lang.css" />
<link rel="stylesheet" href="/threejs/lessons/resources/lesson.css" />
</head>
<body>
<div class="threejs_navbar">
  <div>
    <select class="language">
    <option value="/threejs/lessons/threejs-custom-buffergeometry.html" >English</a>
    <option value="/threejs/lessons/fr/threejs-custom-buffergeometry.html" >Français</a>
    <option value="/threejs/lessons/ja/threejs-custom-buffergeometry.html" >日本語</a>
    <option value="/threejs/lessons/kr/threejs-custom-buffergeometry.html" selected>한국어</a>
    <option value="/threejs/lessons/ru/threejs-custom-buffergeometry.html" >Русский</a>
    <option value="/threejs/lessons/zh_cn/threejs-custom-buffergeometry.html" >中文</a>
</select>


    <a href="#toc">목차</a>
  </div>
</div>
<div class="threejs_header">
  <h1><a href="/threejs/lessons/kr/">threejsfundamentals.org</a></h1>
<style>
#forkongithub a {
    background: #000;
    color: #fff;
    text-decoration: none;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 2rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 300px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(150px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a:hover {
    background: #c11;
    color: #fff;
}
#forkongithub a::before,#forkongithub a::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub a::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
@media (max-width: 900px) {
    #forkongithub a{
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub a{
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><a href="https://github.com/gfxfundamentals/threejsfundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>Three.js 사용자 지정 BufferGeometry</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p><a href="threejs-custom-geometry.html">이전 글</a>에서는 <code class="notranslate" translate="no">Geometry</code>의 사용법에 대해
알아보았습니다. 예고한 대로 이번에는 <code class="notranslate" translate="no">BufferGeometry</code>에 대해 살펴보도록 하죠.
<code class="notranslate" translate="no">BufferGeometry</code>는 비교적 쓰기가 어렵지만 <em>일반적으로</em> 초기화 속도가 빠르고
메모리 점유율이 낮습니다.</p>
<p><a href="threejs-custom-geometry.html">이전 내용</a>을 간단하게 환기하겠습니다. <code class="notranslate" translate="no">Geometry</code>를
만들기 위해 우리는 먼저 꼭지점을 나타내는 <code class="notranslate" translate="no">Vector3</code> 인스턴스(위치값)를 배열로 넘기고,
이 꼭지점 배열의 인덱스 값을 인자로 넘겨 삼각형, <code class="notranslate" translate="no">Face3</code> 인스턴스를 만들었습니다. 또한
각 <code class="notranslate" translate="no">Face3</code> 인스턴스에 삼각형 면 법선이나 꼭지점 법선을 지정할 수 있다는 것, 삼각형 면
또는 각 꼭지점 별로 색을 지정할 수 있다는 것도 배웠죠. 글의 마지막에서는 텍스처 좌표(UVs)
배열의 평행 배열로 UV 매핑을 구현하기도 했습니다(각 삼각형 면마다 배열로 된 UV 배열 하나,
각 꼭지점마다 UV 하나).</p>
<div class="threejs_center"><img src="../resources/threejs-geometry.svg" style="width: 700px"></div>

<p>반면에 <code class="notranslate" translate="no">BufferGeometry</code>는 <code class="notranslate" translate="no">BufferAttribute</code>라는 것을 사용합니다. 각 <code class="notranslate" translate="no">BufferAttribute</code>는
위치(positions), 법선(normals), 색(colors), uv 데이터의 배열이고, 이들을 모으면 각 꼭지점에
대한 <em>평행 배열</em> 형식의 데이터가 되죠.</p>
<div class="threejs_center"><img src="../resources/threejs-attributes.svg" style="width: 700px"></div>

<p>그림을 보면 총 4개의 속성(attribute), <code class="notranslate" translate="no">position</code>, <code class="notranslate" translate="no">normal</code>, <code class="notranslate" translate="no">color</code>, <code class="notranslate" translate="no">uv</code>가 있습니다.
이들은 평행 배열로 각 속성의 N 번째 데이터 묶음이 한 꼭지점의 데이터를 나타냅니다. 표시한
index = 4 위치의 꼭지점 데이터를 보세요. 이 묶음이 하나의 꼭지점을 정의합니다.</p>
<p>이해를 돕기 위해 정육면체의 한 모서리를 강조해보겠습니다.</p>
<div class="threejs_center"><img src="../resources/cube-faces-vertex.svg" style="width: 500px"></div>

<p>이 경우 맞닿은 면의 색이 다르기에, 이 모서리는 각 면에 다른 법선을 제공해야 합니다.
마찬가지로 UV도 달라야 하죠. 이는 <code class="notranslate" translate="no">Geometry</code>와 <code class="notranslate" translate="no">BufferGeometry</code>의 가장 큰 차이점입니다.
<code class="notranslate" translate="no">BufferGeometry</code>는 <code class="notranslate" translate="no">Geometry</code>와 달리 꼭지점은 물론 어떤 요소도 공유할 수 없습니다.
하나의 <em>꼭지점</em>은 위 4개 속성의 묶음이고, 때문에 속성이 달라진다면 그건 다른 꼭지점이
되는 것이죠.</p>
<p>사실 <code class="notranslate" translate="no">Geometry</code>는 <code class="notranslate" translate="no">BufferGeometry</code>와 근본적으로 다르지 않습니다. 사용자가 <code class="notranslate" translate="no">Geometry</code>를
사용하면 Three.js가 알아서 이를 <code class="notranslate" translate="no">BufferGeometry</code> 형식으로 변환해주는 것이죠. 메모리를 더
많이 사용하는 것도 <code class="notranslate" translate="no">Vector3</code>나, <code class="notranslate" translate="no">Vector2</code>, <code class="notranslate" translate="no">Face3</code>, 그리고 기타 데이터를 위와 같은 <code class="notranslate" translate="no">BufferAttribute</code>
형태로 변환하기 때문입니다. 반면에 <code class="notranslate" translate="no">BufferGeometry</code>는 이런 변환 작업을 직접 해줘야 하죠.</p>
<p>이전과 마찬가지로 <code class="notranslate" translate="no">BufferGeometry</code>로 정육면체를 만들어보겠습니다. 굳이 정육면체를 쓰는
이유는 모서리의 꼭지점을 공유하는 듯해도 사실 그렇지 않기 때문이죠. 필요한 꼭지점을
전부 생성한 후, 꼭지점 데이터를 평행 배열로 변환해 <code class="notranslate" translate="no">BufferAttribute</code>를 만들고, 이를
<code class="notranslate" translate="no">BufferGeometry</code>에 추가해야 합니다.</p>
<p>일단 <a href="threejs-custom-geometry.html">이전 글</a>의 텍스처 좌표 설정 예제를 가져옵니다.
<code class="notranslate" translate="no">Geometry</code>를 만드는 코드를 전부 삭제한 뒤, 정육면체를 만드는 데 필요한 데이터를 정렬합니다.
아까 말했듯 꼭지점의 속성 중 하나라도 다르다면 별도의 꼭지점으로 분리해야 합니다. 정육면체의
경우는 총 꼭지점 36개가 필요하죠. 면 6개, 면 하나당 삼각형 2개, 삼각형 하나 당 꼭지점 3개,
총 36개입니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const vertices = [
  // 앞쪽
  { pos: [-1, -1,  1], norm: [ 0,  0,  1], uv: [0, 1], },
  { pos: [ 1, -1,  1], norm: [ 0,  0,  1], uv: [1, 1], },
  { pos: [-1,  1,  1], norm: [ 0,  0,  1], uv: [0, 0], },

  { pos: [-1,  1,  1], norm: [ 0,  0,  1], uv: [0, 0], },
  { pos: [ 1, -1,  1], norm: [ 0,  0,  1], uv: [1, 1], },
  { pos: [ 1,  1,  1], norm: [ 0,  0,  1], uv: [1, 0], },
  // 오른쪽
  { pos: [ 1, -1,  1], norm: [ 1,  0,  0], uv: [0, 1], },
  { pos: [ 1, -1, -1], norm: [ 1,  0,  0], uv: [1, 1], },
  { pos: [ 1,  1,  1], norm: [ 1,  0,  0], uv: [0, 0], },

  { pos: [ 1,  1,  1], norm: [ 1,  0,  0], uv: [0, 0], },
  { pos: [ 1, -1, -1], norm: [ 1,  0,  0], uv: [1, 1], },
  { pos: [ 1,  1, -1], norm: [ 1,  0,  0], uv: [1, 0], },
  // 뒤쪽
  { pos: [ 1, -1, -1], norm: [ 0,  0, -1], uv: [0, 1], },
  { pos: [-1, -1, -1], norm: [ 0,  0, -1], uv: [1, 1], },
  { pos: [ 1,  1, -1], norm: [ 0,  0, -1], uv: [0, 0], },

  { pos: [ 1,  1, -1], norm: [ 0,  0, -1], uv: [0, 0], },
  { pos: [-1, -1, -1], norm: [ 0,  0, -1], uv: [1, 1], },
  { pos: [-1,  1, -1], norm: [ 0,  0, -1], uv: [1, 0], },
  // 왼쪽
  { pos: [-1, -1, -1], norm: [-1,  0,  0], uv: [0, 1], },
  { pos: [-1, -1,  1], norm: [-1,  0,  0], uv: [1, 1], },
  { pos: [-1,  1, -1], norm: [-1,  0,  0], uv: [0, 0], },

  { pos: [-1,  1, -1], norm: [-1,  0,  0], uv: [0, 0], },
  { pos: [-1, -1,  1], norm: [-1,  0,  0], uv: [1, 1], },
  { pos: [-1,  1,  1], norm: [-1,  0,  0], uv: [1, 0], },
  // 상단
  { pos: [ 1,  1, -1], norm: [ 0,  1,  0], uv: [0, 1], },
  { pos: [-1,  1, -1], norm: [ 0,  1,  0], uv: [1, 1], },
  { pos: [ 1,  1,  1], norm: [ 0,  1,  0], uv: [0, 0], },

  { pos: [ 1,  1,  1], norm: [ 0,  1,  0], uv: [0, 0], },
  { pos: [-1,  1, -1], norm: [ 0,  1,  0], uv: [1, 1], },
  { pos: [-1,  1,  1], norm: [ 0,  1,  0], uv: [1, 0], },
  // 하단
  { pos: [ 1, -1,  1], norm: [ 0, -1,  0], uv: [0, 1], },
  { pos: [-1, -1,  1], norm: [ 0, -1,  0], uv: [1, 1], },
  { pos: [ 1, -1, -1], norm: [ 0, -1,  0], uv: [0, 0], },

  { pos: [ 1, -1, -1], norm: [ 0, -1,  0], uv: [0, 0], },
  { pos: [-1, -1,  1], norm: [ 0, -1,  0], uv: [1, 1], },
  { pos: [-1, -1, -1], norm: [ 0, -1,  0], uv: [1, 0], },
];
</code></pre>
<p>다음으로 이 배열을 3개의 평행 배열로 변환합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const positions = [];
const normals = [];
const uvs = [];
for (const vertex of vertices) {
  positions.push(...vertex.pos);
  normals.push(...vertex.norm);
  uvs.push(...vertex.uv);
}
</code></pre>
<p>이제 <code class="notranslate" translate="no">BufferGeometry</code>를 만듭니다. 그리고 각 배열로 <code class="notranslate" translate="no">BufferAttribute</code> 인스턴스를 생성한
뒤 <code class="notranslate" translate="no">BufferGeometry</code>에 추가합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">  const geometry = new THREE.BufferGeometry();
  const positionNumComponents = 3;
  const normalNumComponents = 3;
  const uvNumComponents = 2;
  geometry.setAttribute(
      &#39;position&#39;,
      new THREE.BufferAttribute(new Float32Array(positions), positionNumComponents));
  geometry.setAttribute(
      &#39;normal&#39;,
      new THREE.BufferAttribute(new Float32Array(normals), normalNumComponents));
  geometry.setAttribute(
      &#39;uv&#39;,
      new THREE.BufferAttribute(new Float32Array(uvs), uvNumComponents));
</code></pre>
<p>이때 정확히 Three.js가 원하는 속성 이름을 써야 합니다(사용자 지정 쉐이더를 만들 때와는
달리). 이 경우에는 <code class="notranslate" translate="no">position</code>, <code class="notranslate" translate="no">normal</code>, <code class="notranslate" translate="no">uv</code>이죠. 꼭지점 색을 지정하려면 <code class="notranslate" translate="no">color</code> 속성을
지정해야 합니다.</p>
<p>아까 <code class="notranslate" translate="no">positions</code>, <code class="notranslate" translate="no">normals</code>, <code class="notranslate" translate="no">uvs</code>, 3개의 자바스크립트 순수 배열을 생성했습니다.
그리고 위에서 해당 배열을 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/TypedArray">형식화 배열</a>,
<code class="notranslate" translate="no">Float32Array</code>로 변환했죠. <code class="notranslate" translate="no">BufferAttribute</code>는 순수 배열이 아니라 형식화 배열을
인자로 받습니다. 또한 하나의 꼭지점에 몇 개의 요소를 사용할 지 지정해줘야 하죠.
위치(position)과 법선(normal)의 경우 x, y, z 총 3개이고, UV는 u, v 총 2개입니다.</p>
<p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-custom-buffergeometry-cube.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-custom-buffergeometry-cube.html" target="_blank">새 탭에서 보기</a>
</div>

</p>
<p>데이터가 너무 많네요. 크게 구조를 바꾸긴 어렵지만, 꼭지점을 인덱스로 참조하게끔 바꾸면
조금 나을 듯합니다. 정육면체 데이터를 다시 봅시다. 각 면은 2개의 삼각형, 삼각형 하나에는
꼭지점이 3개 있으므로 면 하나에는 총 6개의 꼭지점이 있습니다. 하지만 이 중 꼭지점 2개는
완전히 같죠(같은 위치, 같은 법선, 같은 uv). 중복된 꼭지점을 제거하고 인덱스로 데이터를
불러오도록 바꿀 수 있겠네요. 먼저 중복된 꼭지점을 제거하겠습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const vertices = [
  // 앞쪽
  { pos: [-1, -1,  1], norm: [ 0,  0,  1], uv: [0, 1], }, // 0
  { pos: [ 1, -1,  1], norm: [ 0,  0,  1], uv: [1, 1], }, // 1
  { pos: [-1,  1,  1], norm: [ 0,  0,  1], uv: [0, 0], }, // 2
-
-  { pos: [-1,  1,  1], norm: [ 0,  0,  1], uv: [0, 0], },
-  { pos: [ 1, -1,  1], norm: [ 0,  0,  1], uv: [1, 1], },
  { pos: [ 1,  1,  1], norm: [ 0,  0,  1], uv: [1, 0], }, // 3
  // 오른쪽
  { pos: [ 1, -1,  1], norm: [ 1,  0,  0], uv: [0, 1], }, // 4
  { pos: [ 1, -1, -1], norm: [ 1,  0,  0], uv: [1, 1], }, // 5
-
-  { pos: [ 1,  1,  1], norm: [ 1,  0,  0], uv: [0, 0], },
-  { pos: [ 1, -1, -1], norm: [ 1,  0,  0], uv: [1, 1], },
  { pos: [ 1,  1,  1], norm: [ 1,  0,  0], uv: [0, 0], }, // 6
  { pos: [ 1,  1, -1], norm: [ 1,  0,  0], uv: [1, 0], }, // 7
  // 뒤쪽
  { pos: [ 1, -1, -1], norm: [ 0,  0, -1], uv: [0, 1], }, // 8
  { pos: [-1, -1, -1], norm: [ 0,  0, -1], uv: [1, 1], }, // 9
-
-  { pos: [ 1,  1, -1], norm: [ 0,  0, -1], uv: [0, 0], },
-  { pos: [-1, -1, -1], norm: [ 0,  0, -1], uv: [1, 1], },
  { pos: [ 1,  1, -1], norm: [ 0,  0, -1], uv: [0, 0], }, // 10
  { pos: [-1,  1, -1], norm: [ 0,  0, -1], uv: [1, 0], }, // 11
  // 왼쪽
  { pos: [-1, -1, -1], norm: [-1,  0,  0], uv: [0, 1], }, // 12
  { pos: [-1, -1,  1], norm: [-1,  0,  0], uv: [1, 1], }, // 13
-
-  { pos: [-1,  1, -1], norm: [-1,  0,  0], uv: [0, 0], },
-  { pos: [-1, -1,  1], norm: [-1,  0,  0], uv: [1, 1], },
  { pos: [-1,  1, -1], norm: [-1,  0,  0], uv: [0, 0], }, // 14
  { pos: [-1,  1,  1], norm: [-1,  0,  0], uv: [1, 0], }, // 15
  // 상단
  { pos: [ 1,  1, -1], norm: [ 0,  1,  0], uv: [0, 1], }, // 16
  { pos: [-1,  1, -1], norm: [ 0,  1,  0], uv: [1, 1], }, // 17
-
-  { pos: [ 1,  1,  1], norm: [ 0,  1,  0], uv: [0, 0], },
-  { pos: [-1,  1, -1], norm: [ 0,  1,  0], uv: [1, 1], },
  { pos: [ 1,  1,  1], norm: [ 0,  1,  0], uv: [0, 0], }, // 18
  { pos: [-1,  1,  1], norm: [ 0,  1,  0], uv: [1, 0], }, // 19
  // 하단
  { pos: [ 1, -1,  1], norm: [ 0, -1,  0], uv: [0, 1], }, // 20
  { pos: [-1, -1,  1], norm: [ 0, -1,  0], uv: [1, 1], }, // 21
-
-  { pos: [ 1, -1, -1], norm: [ 0, -1,  0], uv: [0, 0], },
-  { pos: [-1, -1,  1], norm: [ 0, -1,  0], uv: [1, 1], },
  { pos: [ 1, -1, -1], norm: [ 0, -1,  0], uv: [0, 0], }, // 22
  { pos: [-1, -1, -1], norm: [ 0, -1,  0], uv: [1, 0], }, // 23
];
</code></pre>
<p>이제 꼭지점 24개만 남았습니다. 중복되는 꼭지점은 없죠. 이제 <code class="notranslate" translate="no">BufferGeometry.setIndex</code>
메서드에 각 꼭지점 데이터의 인덱스값 36개-삼각형이 12개이므로-를 넘겨줍니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">geometry.setAttribute(
    &#39;position&#39;,
    new THREE.BufferAttribute(positions, positionNumComponents));
geometry.setAttribute(
    &#39;normal&#39;,
    new THREE.BufferAttribute(normals, normalNumComponents));
geometry.setAttribute(
    &#39;uv&#39;,
    new THREE.BufferAttribute(uvs, uvNumComponents));

+geometry.setIndex([
+   0,  1,  2,   2,  1,  3,  // 앞쪽
+   4,  5,  6,   6,  5,  7,  // 오른쪽
+   8,  9, 10,  10,  9, 11,  // 뒤쪽
+  12, 13, 14,  14, 13, 15,  // 왼쪽
+  16, 17, 18,  18, 17, 19,  // 상단
+  20, 21, 22,  22, 21, 23,  // 하단
+]);
</code></pre>
<p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-custom-buffergeometry-cube-indexed.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-custom-buffergeometry-cube-indexed.html" target="_blank">새 탭에서 보기</a>
</div>

</p>
<p><code class="notranslate" translate="no">Geometry</code>와 마찬가지로 <code class="notranslate" translate="no">BufferGeometry</code>에 법선을 지정하지 않았다면 <a href="BufferGeometry.computeVertexNormals"><code class="notranslate" translate="no">computeVertexNormals</code></a>
메서드를 호출해 자동으로 법선을 지정할 수 있습니다. 다만 데이터가 조금이라도 다르다면
꼭지점을 공유할 수 없기에 <code class="notranslate" translate="no">Geometry</code>의 경우와는 조금 다른 결과를 보여줄 겁니다.</p>
<div class="spread">
  <div>
    <div data-diagram="bufferGeometryCylinder"></div>
    <div class="code">BufferGeometry</div>
  </div>
  <div>
    <div data-diagram="geometryCylinder"></div>
    <div class="code">Geometry</div>
  </div>
</div>

<p>위 두 원통은 <code class="notranslate" translate="no">computeVertexNormals</code> 메서드를 호출해 법선을 생성했습니다. 자세히 보면
왼쪽 원통에 이음매가 있는 게 보일 텐데, 이는 원통의 끝과 시작점의 UV가 달라 꼭지점을
공유할 수 없기 때문입니다. 그다지 큰 문제는 아니지만, 알아두어 나쁠 건 없죠. 이를 해결하려면
법선을 직접 지정해야 합니다.</p>
<p>아까는 처음에 순수 배열을 썼지만, 처음부터 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/TypedArray">형식화 배열</a>을
사용할 수도 있습니다. 다만 형식화 배열은 초기화할 때 미리 크기를 지정해줘야 합니다.
그렇게 어려운 일은 아니지만, 순수 배열은 <code class="notranslate" translate="no">push</code> 메서드로 요소를 추가하고 바뀐
길이를 <code class="notranslate" translate="no">length</code> 속성으로 확인할 수 있습니다. 하지만 형식화 배열을 사용하면 어디서
요소를 추가했는지 직접 일일이 기록해야 하죠.</p>
<p>예제의 경우는 사전에 정해진 데이터를 사용하기에 배열 길이를 미리 구하는 게 어렵지
않습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-const positions = [];
-const normals = [];
-const uvs = [];
+const numVertices = vertices.length;
+const positionNumComponents = 3;
+const normalNumComponents = 3;
+const uvNumComponents = 2;
+const positions = new Float32Array(numVertices * positionNumComponents);
+const normals = new Float32Array(numVertices * normalNumComponents);
+const uvs = new Float32Array(numVertices * uvNumComponents);
+let posNdx = 0;
+let nrmNdx = 0;
+let uvNdx = 0;
for (const vertex of vertices) {
-  positions.push(...vertex.pos);
-  normals.push(...vertex.norm);
-  uvs.push(...vertex.uv);
+  positions.set(vertex.pos, posNdx);
+  normals.set(vertex.norm, nrmNdx);
+  uvs.set(vertex.uv, uvNdx);
+  posNdx += positionNumComponents;
+  nrmNdx += normalNumComponents;
+  uvNdx += uvNumComponents;
}

geometry.setAttribute(
    &#39;position&#39;,
-    new THREE.BufferAttribute(new Float32Array(positions), positionNumComponents));
+    new THREE.BufferAttribute(positions, positionNumComponents));
geometry.setAttribute(
    &#39;normal&#39;,
-    new THREE.BufferAttribute(new Float32Array(normals), normalNumComponents));
+    new THREE.BufferAttribute(normals, normalNumComponents));
geometry.setAttribute(
    &#39;uv&#39;,
-    new THREE.BufferAttribute(new Float32Array(uvs), uvNumComponents));
+    new THREE.BufferAttribute(uvs, uvNumComponents));

geometry.setIndex([
   0,  1,  2,   2,  1,  3,  // 앞쪽
   4,  5,  6,   6,  5,  7,  // 오른쪽
   8,  9, 10,  10,  9, 11,  // 뒤쪽
  12, 13, 14,  14, 13, 15,  // 왼쪽
  16, 17, 18,  18, 17, 19,  // 상단
  20, 21, 22,  22, 21, 23,  // 하단
]);
</code></pre>
<p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-custom-buffergeometry-cube-typedarrays.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-custom-buffergeometry-cube-typedarrays.html" target="_blank">새 탭에서 보기</a>
</div>

</p>
<p>꼭지점의 일부를 수정하고 싶다면 형식화 배열을 사용하는 게 좋습니다.</p>
<p>뭔가 꼭지점을 동적으로 수정하는 예제를 찾아보려고 노력했는데, 찾기가 어렵네요.
그냥 구체를 만들고 구체의 각 사분면(quad)을 중심으로부터 안팎으로 움직여보겠습니다.</p>
<p>아래는 구체의 위치값과 인덱스를 생성하는 코드입니다. 사분면 내의 꼭지점은 서로
공유할 수 있지만, 사분면은 각각 움직여야 하므로 사분면끼리는 공유하지 않도록
합니다.</p>
<p>구체의 정점을 구하기 위해 좀 더 복잡한 방법을 쓸 수도 있지만, 귀찮으니 그냥
<code class="notranslate" translate="no">Object3D</code> 3개를 계층 구조로 배열해 쓰겠습니다. 이 방식에 대해서는 <a href="threejs-optimize-lots-of-objects.html">많은 물체를
최적화하는 방법</a>에서 더 자세히 다루겠습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function makeSpherePositions(segmentsAround, segmentsDown) {
  const numVertices = segmentsAround * segmentsDown * 6;
  const numComponents = 3;
  const positions = new Float32Array(numVertices * numComponents);
  const indices = [];

  const longHelper = new THREE.Object3D();
  const latHelper = new THREE.Object3D();
  const pointHelper = new THREE.Object3D();
  longHelper.add(latHelper);
  latHelper.add(pointHelper);
  pointHelper.position.z = 1;
  const temp = new THREE.Vector3();

  function getPoint(lat, long) {
    latHelper.rotation.x = lat;
    longHelper.rotation.y = long;
    longHelper.updateMatrixWorld(true);
    return pointHelper.getWorldPosition(temp).toArray();
  }

  let posNdx = 0;
  let ndx = 0;
  for (let down = 0; down &lt; segmentsDown; ++down) {
    const v0 = down / segmentsDown;
    const v1 = (down + 1) / segmentsDown;
    const lat0 = (v0 - 0.5) * Math.PI;
    const lat1 = (v1 - 0.5) * Math.PI;

    for (let across = 0; across &lt; segmentsAround; ++across) {
      const u0 = across / segmentsAround;
      const u1 = (across + 1) / segmentsAround;
      const long0 = u0 * Math.PI * 2;
      const long1 = u1 * Math.PI * 2;

      positions.set(getPoint(lat0, long0), posNdx);  posNdx += numComponents;
      positions.set(getPoint(lat1, long0), posNdx);  posNdx += numComponents;
      positions.set(getPoint(lat0, long1), posNdx);  posNdx += numComponents;
      positions.set(getPoint(lat1, long1), posNdx);  posNdx += numComponents;

      indices.push(
        ndx, ndx + 1, ndx + 2,
        ndx + 2, ndx + 1, ndx + 3,
      );
      ndx += 4;
    }
  }
  return { positions, indices };
}
</code></pre>
<p>만든 함수를 다음처럼 호출합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const segmentsAround = 24;
const segmentsDown = 16;
const { positions, indices } = makeSpherePositions(segmentsAround, segmentsDown);
</code></pre>
<p>여기서 반환된 위치값(positions)은 구체의 위치값을 기반으로 합니다. 이는 법선의 값(normals)과
같으니 법선을 따로 구할 필요 없이 위치값을 복사해서 쓰면 됩니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const normals = positions.slice();
</code></pre>
<p>다음으로 각 속성을 지정합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const geometry = new THREE.BufferGeometry();
const positionNumComponents = 3;
const normalNumComponents = 3;

+const positionAttribute = new THREE.BufferAttribute(positions, positionNumComponents);
+positionAttribute.setUsage(THREE.DynamicDrawUsage);
geometry.setAttribute(
    &#39;position&#39;,
+    positionAttribute);
geometry.setAttribute(
    &#39;normal&#39;,
    new THREE.BufferAttribute(normals, normalNumComponents));
geometry.setIndex(indices);
</code></pre>
<p>예제에서 차이점이 있는 부분을 표시해 두었습니다. 위치 속성에 참조값을 넘겨주었고, 이
속성이 동적이라고 명시했습니다. 이는 Three.js에게 해당 속성을 자주 변경될 수 있음을
알려주는 역할이죠.</p>
<p>이제 <code class="notranslate" translate="no">render</code> 함수에서 매 프레임마다 법선을 기준으로 위치값을 변경해줍니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const temp = new THREE.Vector3();

...

for (let i = 0; i &lt; positions.length; i += 3) {
  const quad = (i / 12 | 0);
  const ringId = quad / segmentsAround | 0;
  const ringQuadId = quad % segmentsAround;
  const ringU = ringQuadId / segmentsAround;
  const angle = ringU * Math.PI * 2;
  temp.fromArray(normals, i);
  temp.multiplyScalar(THREE.MathUtils.lerp(1, 1.4, Math.sin(time + ringId + angle) * .5 + .5));
  temp.toArray(positions, i);
}
positionAttribute.needsUpdate = true;
</code></pre>
<p>마지막으로 <code class="notranslate" translate="no">positionAttribute.needsUpdate</code> 속성을 활성화해 변화를 감지하도록 합니다.</p>
<p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-custom-buffergeometry-dynamic.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-custom-buffergeometry-dynamic.html" target="_blank">새 탭에서 보기</a>
</div>

</p>
<p><code class="notranslate" translate="no">Geometry</code>와 <code class="notranslate" translate="no">BufferGeometry</code> 중 어떤 것을 쓸 것인지는 전적으로 여러분의 선택입니다.
이 글이 <code class="notranslate" translate="no">BufferGeometry</code>로 사용자 지정 geometry를 만들고, <code class="notranslate" translate="no">BufferAttribute</code>를 다루는
데 도움이 되었으면 좋겠네요.</p>
<p><canvas id="c"></canvas></p>
<script type="module" src="../resources/threejs-custom-buffergeometry.js"></script>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/threejs/lessons/threejs-custom-buffergeometry.html" >English</a>
    <option value="/threejs/lessons/fr/threejs-custom-buffergeometry.html" >Français</a>
    <option value="/threejs/lessons/ja/threejs-custom-buffergeometry.html" >日本語</a>
    <option value="/threejs/lessons/kr/threejs-custom-buffergeometry.html" selected>한국어</a>
    <option value="/threejs/lessons/ru/threejs-custom-buffergeometry.html" >Русский</a>
    <option value="/threejs/lessons/zh_cn/threejs-custom-buffergeometry.html" >中文</a>
</select>


        <div id="toc">
          <ul>  <li>Three.js란?</li>
        <ul>
          <li><a href="/threejs/lessons/kr/threejs-fundamentals.html">Three.js란?</a></li>
<li><a href="/threejs/lessons/kr/threejs-responsive.html">반응형 디자인</a></li>
<li><a href="/threejs/lessons/kr/threejs-prerequisites.html">먼저 알아야 할 것들</a></li>
<li><a href="/threejs/lessons/kr/threejs-setup.html">개발 환경</a></li>
        </ul>
  <li>기본 구조</li>
        <ul>
          <li><a href="/threejs/lessons/kr/threejs-primitives.html">원시 모델</a></li>
<li><a href="/threejs/lessons/kr/threejs-scenegraph.html">씬 그래프</a></li>
<li><a href="/threejs/lessons/kr/threejs-materials.html">재질(Materials)</a></li>
<li><a href="/threejs/lessons/kr/threejs-textures.html">텍스처(Textures)</a></li>
<li><a href="/threejs/lessons/kr/threejs-lights.html">조명(Lights)</a></li>
<li><a href="/threejs/lessons/kr/threejs-cameras.html">카메라(Cameras)</a></li>
<li><a href="/threejs/lessons/kr/threejs-shadows.html">그림자(Shadows)</a></li>
<li><a href="/threejs/lessons/kr/threejs-fog.html">안개(Fog)</a></li>
<li><a href="/threejs/lessons/kr/threejs-rendertargets.html">렌더 타겟(Render Targets)</a></li>
<li><a href="/threejs/lessons/kr/threejs-custom-geometry.html">사용자 지정 Geometry</a></li>
<li><a href="/threejs/lessons/kr/threejs-custom-buffergeometry.html">사용자 지정 BufferGeometry</a></li>
        </ul>
  <li>팁</li>
        <ul>
          <li><a href="/threejs/lessons/kr/threejs-rendering-on-demand.html">불필요한 렌더링 없애기</a></li>
<li><a href="/threejs/lessons/kr/threejs-debugging-javascript.html">Debugging JavaScript</a></li>
<li><a href="/threejs/lessons/kr/threejs-debugging-glsl.html">Debugging GLSL</a></li>
<li><a href="/threejs/lessons/kr/threejs-tips.html#screenshot">Taking a screenshot</a></li>
<li><a href="/threejs/lessons/kr/threejs-tips.html#preservedrawingbuffer">Prevent the Canvas Being Cleared</a></li>
<li><a href="/threejs/lessons/kr/threejs-tips.html#tabindex">Get Keyboard Input From a Canvas</a></li>
<li><a href="/threejs/lessons/kr/threejs-tips.html#transparent-canvas">Make the Canvas Transparent</a></li>
<li><a href="/threejs/lessons/kr/threejs-tips.html#html-background">Use three.js as Background in HTML</a></li>
        </ul>
  <li>최적화하기</li>
        <ul>
          <li><a href="/threejs/lessons/kr/threejs-optimize-lots-of-objects.html">요소가 많을 때 최적화하는 방법</a></li>
<li><a href="/threejs/lessons/kr/threejs-optimize-lots-of-objects-animated.html">애니메이션 요소가 많을 때 최적화하는 방법</a></li>
<li><a href="/threejs/lessons/kr/threejs-offscreencanvas.html">웹 워커에서 OffscreenCanvas 사용하기</a></li>
        </ul>
  <li>활용하기</li>
        <ul>
          <li><a href="/threejs/lessons/kr/threejs-load-obj.html">.OBJ 파일 불러오기</a></li>
<li><a href="/threejs/lessons/kr/threejs-load-gltf.html">.GLTF 파일 불러오기</a></li>
<li><a href="/threejs/lessons/kr/threejs-backgrounds.html">배경, 하늘 상자 추가하기</a></li>
<li><a href="/threejs/lessons/kr/threejs-transparency.html">물체의 투명도 설정하기</a></li>
<li><a href="/threejs/lessons/kr/threejs-multiple-scenes.html">다중 캔버스, 다중 장면 만들기</a></li>
<li><a href="/threejs/lessons/kr/threejs-picking.html">물체를 마우스로 피킹하기</a></li>
<li><a href="/threejs/lessons/kr/threejs-post-processing.html">후처리</a></li>
<li><a href="/threejs/lessons/kr/threejs-post-processing-3dlut.html">LUT 파일로 후처리 효과 적용하기</a></li>
<li><a href="/threejs/lessons/kr/threejs-shadertoy.html">Using Shadertoy shaders</a></li>
<li><a href="/threejs/lessons/kr/threejs-align-html-elements-to-3d.html">Aligning HTML Elements to 3D</a></li>
<li><a href="/threejs/lessons/kr/threejs-indexed-textures.html">Using Indexed Textures for Picking and Color</a></li>
<li><a href="/threejs/lessons/kr/threejs-canvas-textures.html">Using A Canvas for Dynamic Textures</a></li>
<li><a href="/threejs/lessons/kr/threejs-billboards.html">Billboards and Facades</a></li>
<li><a href="/threejs/lessons/kr/threejs-cleanup.html">Freeing Resources</a></li>
<li><a href="/threejs/lessons/kr/threejs-voxel-geometry.html">Making Voxel Geometry (Minecraft)</a></li>
<li><a href="/threejs/lessons/kr/threejs-game.html">Start making a Game.</a></li>
        </ul>
  <li>웹VR</li>
        <ul>
          <li><a href="/threejs/lessons/kr/threejs-webvr.html">VR - Basics</a></li>
<li><a href="/threejs/lessons/kr/threejs-webvr-look-to-select.html">VR - Look To Select</a></li>
<li><a href="/threejs/lessons/kr/threejs-webvr-point-to-select.html">VR - Point To Select</a></li>
        </ul>
  <li>레퍼런스</li>
        <ul>
          <li><a href="/threejs/lessons/kr/threejs-material-table.html">Material Table</a></li>
        </ul></ul>
<ul>
  <li>바로가기</li>
  <ul>
    <li><a href="https://github.com/gfxfundamentals/threejsfundamentals">Github</a></li>
    <li><a href="https://threejs.org">Three.js</a></li>
    <li><a href="https://threejs.org/docs/">Three.js docs</a></li>
  </ul>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        
    <div>
      <a href="http://stackoverflow.com/questions/tagged/three.js">Stackoverflow</a>
      /
      <a href="http://github.com/greggman/threefundamentals/issues">Github</a>
    </div>
  

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'threejsfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'Three.js 사용자 지정 BufferGeometry';
            var disqus_title = 'Three.js 사용자 지정 BufferGeometry';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("threejsfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/threejs/lessons/resources/prettify.js"></script>
<script src="/threejs/lessons/resources/lesson.js"></script>
<script>
(function() {
  if (window.location.hostname.indexOf("threejsfundamentals.org") < 0) {
      return;
  }

  function addScript(src, fn) {
    const script = document.createElement('script');
    const firstScript = document.getElementsByTagName('script')[0];
    script.async = true;
    script.defer = true;
    if (fn) {
      script.addEventListener('load', fn);
    }
    script.src = src;
    firstScript.parentNode.insertBefore(script, firstScript);
  }

  addScript('//cdn.webglstats.com/stat.js');
  addScript('https://www.googletagmanager.com/gtag/js?id=UA-120733518-1', () => {
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-120733518-1');
  });
}());
</script>


</html>



