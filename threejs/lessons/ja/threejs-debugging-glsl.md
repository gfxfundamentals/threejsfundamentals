Title: Three.jsでのGLSLデバッグ
Description: GLSLシェーダーをデバッグする方法
TOC: GLSLのデバッグ

このサイトではJavaScriptを教えていないのと同様に、これまでGLSLは教えていませんでした。
それは本当に大きなトピックです。GLSLを学びたいのであれば[これらの記事](https://webglfundamentals.org)から始めてみて下さい。

すでにGLSLを知っている場合は、デバッグのヒントをいくつか紹介します。

新しくGLSLシェーダーを作り何も表示されない場合、一般的に最初にするのはフラグメントシェーダーでソリッドカラーに変更する事です。例えば、シェーダの一番下を以下のように書きます。

```glsl
void main() {

  ...

  gl_FragColor = vec4(1, 0, 0, 1);  // red
}
```

描画したオブジェクトを見ると、その問題がフラグメントシェーダーに関係している事がわかります。悪いテクスチャ、初期化されていないuniform変数、間違った値を持つuniform変数が原因かもしれませんが、見るべきポイントがあります。

いくつかをテストするために入力の一部を描画してみようと思います。
例えばフラグメントシェーダーで法線を使用している場合は次のように追加します。

```glsl
gl_FragColor = vec4(vNormal * 0.5 + 0.5, 1);
```

法線は-1から+1までなので、0.5を掛けて0.5を足すと0.0から1.0までの値が得られ、色で判別できて便利です。

これをいくつか試してみると、*通常*ではどのように見えるかわかります。
もしあなたが通常がわからない場合、どこを見れば良いかのヒントがあります。
フラグメントシェーダで法線を操作している場合、その操作の結果を描画するために同じテクニックが使えます。

<div class="threejs_center"><img src="resources/images/standard-primitive-normals.jpg" style="width: 650px;"></div>

同様にテクスチャを使用している場合も、テクスチャ座標があるので以下のように描画できます。

```glsl
gl_FragColor = vec4(fract(vUv), 0, 1);
```

`fract` は、0から1の範囲外のテクスチャ座標を使用している場合に使用します。
これは `texture.repeat` が1よりも大きい値に設定されている場合によく見られます。

<div class="threejs_center"><img src="resources/images/standard-primitive-uvs.jpg" style="width: 650px;"></div>

フラグメントシェーダの全ての値に対して同様の事ができます。
その範囲を把握し、0.0から1.0にスケーリングして `gl_FragColor` を設定するコードを追加します。

テクスチャを確認するには `CanvasTexture` や `DataTexture` が動作するもので試してみて下さい。

逆に言えば `gl_FragColor` を赤に設定しても何も表示されない場合、問題は頂点シェーダに関連したものにあるかもしれません。
一部の行列が間違っていたり、attributesが間違ったデータを持っていたり、設定が間違っていたりする事があります。

私ならまず行列を見ます。`renderer.renderer.render(scene, camera)` 呼出直後にブレークポイントを設定し、インスペクタで展開を始めるかもしれません。
カメラのワールド行列と投影行列は、少なくとも`NaN`sでいっぱいではないのか？
シーンを展開し `children` を見てみると、ワールド行列が合理的に見える（ `NaN` sがない）、各行列の最後の4つの値がシーンにとって合理的に見える事を確認します。
シーンが50 x 50 x 50 x 50の単位である事を期待し、いくつかの行列が552352623.123を表示している場合、明らかに何か間違っているのがわかります。

<div class="threejs_center"><img src="resources/images/inspect-matrices.gif"></div>

フラグメントシェーダーで行ったのと同じように、頂点シェーダーの値をフラグメントシェーダーに渡すと頂点シェーダーから値を描画する事もできます。
両方のシェーダーでvaryingを宣言し、正しいかどうかわからない値を渡します。
実際にシェーダーが法線を使っている場合、値が0.0から1.0になるように `vNormal` を値に設定しフラグメントシェーダーを変更して表示するようにします。
描画結果を見て予想に合っているかどうかを確認します。

もう一つの良い点はよりシンプルなシェーダーを使う事です。
`MeshBasicMaterial` でデータを描画できますか？
可能であれば試してみて期待通りに表示される事を確認して下さい。

期待通りでない場合、ジオメトリをビジュアライズできる最もシンプルな頂点シェーダーは何でしょうか？
通常は

```glsl
gl_Position = projection * modelView * vec4(position.xyz, 1);
```

それが動作する場合は、一度に少しずつ変更を追加していきます。

もう一つの方法は[Shader Editor extension for Chrome](https://chrome.google.com/webstore/detail/shader-editor/ggeaidddejpbakgafapihjbgdlbbbpob?hl=en)を使うか、他のブラウザでは同様なものを使う事です。
他のシェーダーがどのように動作してるか見る良い方法です。また、上記で記載してきたフラグメントシェーダーの変更を行うと、ライブで結果が見る事ができるので良いです。
