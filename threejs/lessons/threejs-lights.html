<!DOCTYPE html>
<!-- this file is auto-generated from threejs/lessons/threejs-lights.md. Do not edited directly -->
<!--
Copyright 2018, Google Inc.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of Google Inc. nor the names of their
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta property="og:title" content="Three.js Lights" />
<meta property="og:type" content="website" />
<meta property="og:image" content="http://threejsfundamentals.org/threejs/lessons/resources/threejsfundamentals.jpg" />
<meta property="og:description" content="Setting up Lights" />
<meta property="og:url" content="http://threejsfundamentals.org/threejs/lessons/threejs-lights.html" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site" content="@greggman" />
<meta name="twitter:creator" content="@greggman" />
<meta name="twitter:domain" content="threejsfundamentals.org" />
<meta name="twitter:title" content="Three.js Lights" />
<meta name="twitter:url" content="http://threejsfundamentals.org/threejs/lessons/threejs-lights.html" />
<meta name="twitter:description" content="Setting up Lights" />
<meta name="twitter:image:src" content="http://threejsfundamentals.org/threejs/lessons/resources/threejsfundamentals.jpg" />


<title>Three.js Lights</title>
<link href="/threejs/lessons/resources/threejsfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/threejs/lessons/resources/lesson.css" type="text/css" />
</head>
<body>
<div class="threejs_navbar">
  <div>
    <select class="language">
    <option value="/threejs/lessons/threejs-lights.html" selected>English</a>
</select>


    <a href="#toc">Table of Contents</a>
  </div>
</div>
<div class="threejs_header">
  <h1><a href="/">threejsfundamentals.org</a></h1>
</div>


<div class="container">
  <div class="lesson-title">
    <h1>Three.js Lights</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>This article is part of a series of articles about three.js. The
first article is <a href="three-fundamentals.html">three.js fundamentals</a>. If
you haven&#39;t read that yet and you&#39;re new to three.js you might want to
consider starting there. The 
<a href="threejs-textures.html">previous article was about textures</a>.</p>
<p>Let go over how to use the various kinds of lights in three.</p>
<p>Starting with one of our previous samples let&#39;s update the camera.
We&#39;ll set the field of view to 45 degrees, the far plane to 100 units,
and we&#39;ll move the camera 10 units up and 20 units back from the origin</p>
<pre><code class="lang-javascript">*const fov = 45;
const aspect = 2;  // the canvas default
const zNear = 0.1;
*const zFar = 100;
const camera = new THREE.PerspectiveCamera(fov, aspect, zNear, zFar);
+camera.position.set(0, 10, 20);
</code></pre>
<p>Next let&#39;s add <code>OrbitControls</code>. <code>OrbitControls</code> let the user spin
or <em>orbit</em> the camera around some point. The <code>OrbitControls</code> are
an optional feature of three.js so first we need to include them
in our page</p>
<pre><code class="lang-javascript">&lt;script src=&quot;resources/threejs/r94/three.min.js&quot;&gt;&lt;/script&gt;
+&lt;script src=&quot;resources/threejs/r94/js/controls/OrbitControls.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>Then we can use them. We pass the <code>OrbitControls</code> a camera to 
control and the DOM element to use to get input events</p>
<pre><code class="lang-javascript">const controls = new THREE.OrbitControls(camera, canvas);
controls.target.set(0, 5, 0);
controls.update();
</code></pre>
<p>We also set the target to orbit around to 5 units above the origin
and then call <code>controls.update</code> so the controls will use the new
target.</p>
<p>Next up let&#39;s make some things to light up. First we&#39;ll make ground
plane. We&#39;ll apply a tiny 2x2 pixel checkerboard texture that looks
like this</p>
<div class="threejs_center">
  <img src="../resources/images/checker.png" class="border" style="
    image-rendering: pixelated;
    width: 128px;
  ">
</div>

<p>First we load the texture, set it to repeating, set the filtering to
nearest, and set how many times we want it to repeat. Since the
texture is a 2x2 pixel checkerboard, by repeating and setting the
repeat to half the size of the plane each check on the checkerboard
will be exactly 1 unit large;</p>
<pre><code class="lang-javascript">const planeSize = 40;

const loader = new THREE.TextureLoader();
const texture = loader.load(&#39;resources/images/checker.png&#39;);
texture.wrapS = THREE.RepeatWrapping;
texture.wrapT = THREE.RepeatWrapping;
texture.magFilter = THREE.NearestFilter;
const repeats = planeSize / 2;
texture.repeat.set(repeats, repeats);
</code></pre>
<p>We then make a plane geometry, a material for the plane, and mesh
to insert it in the scene. Planes default to being in the XY plane
but the ground is in the XZ plane so we rotate it.</p>
<pre><code class="lang-javascript">const planeGeo = new THREE.PlaneBufferGeometry(planeSize, planeSize);
const planeMat = new THREE.MeshPhongMaterial({
  map: texture,
  side: THREE.DoubleSide,
});
const mesh = new THREE.Mesh(planeGeo, planeMat);
mesh.rotation.x = Math.PI * -.5;
scene.add(mesh);
</code></pre>
<p>Let&#39;s add a cube and a sphere so we have 3 things to light including the plane</p>
<pre><code class="lang-javascript">{
  const cubeSize = 4;
  const cubeGeo = new THREE.BoxBufferGeometry(cubeSize, cubeSize, cubeSize);
  const cubeMat = new THREE.MeshPhongMaterial({color: &#39;#8AC&#39;});
  const mesh = new THREE.Mesh(cubeGeo, cubeMat);
  mesh.position.set(cubeSize + 1, cubeSize / 2, 0);
  scene.add(mesh);
}
{
  const sphereRadius = 3;
  const sphereWidthDivisions = 32;
  const sphereHeightDivisions = 16;
  const sphereGeo = new THREE.SphereBufferGeometry(sphereRadius, sphereWidthDivisions, sphereHeightDivisions);
  const sphereMat = new THREE.MeshPhongMaterial({color: &#39;#CA8&#39;});
  const mesh = new THREE.Mesh(sphereGeo, sphereMat);
  mesh.position.set(-sphereRadius - 1, sphereRadius + 2, 0);
  scene.add(mesh);
}
</code></pre>
<p>Now that we have a scene to light up let&#39;s add lights!</p>
<h2 id="-ambientlight-"><code>AmbientLight</code></h2>
<p>First let&#39;s make an <code>AmbientLight</code></p>
<pre><code class="lang-javascript">const color = 0xFFFFFF;
const intensity = 1;
const light = new THREE.AmbientLight(color, intensity);
scene.add(light);
</code></pre>
<p>Let&#39;s also make it so we can adjust the light&#39;s parameters.
We&#39;ll use <a href="https://github.com/dataarts/dat.gui">dat.GUI</a> again. 
To be able to adjust the color via dat.GUI we need a small helper
that presents a property to dat.GUI that looks like a CSS hex color string
(eg: <code>#FF8844</code>). Our helper will get the color from a named property,
convert it to a hex string to offer to dat.GUI. When dat.GUI tries
to set the helper&#39;s property we&#39;ll assign the result back to the light&#39;s
color. </p>
<p>Here&#39;s the helper:</p>
<pre><code class="lang-javascript">class ColorGUIHelper {
  constructor(object, prop) {
    this.object = object;
    this.prop = prop;
  }
  get value() {
    return `#${this.object[this.prop].getHexString()}`;
  }
  set value(hexString) {
    this.object[this.prop].set(hexString);
  }
}
</code></pre>
<p>And here&#39;s our code setting up dat.GUI</p>
<pre><code class="lang-javascript">const gui = new dat.GUI();
gui.addColor(new ColorGUIHelper(light, &#39;color&#39;), &#39;value&#39;).name(&#39;color&#39;);
gui.add(light, &#39;intensity&#39;, 0, 2);
</code></pre>
<p>And here&#39;s the result</p>
<p><div class="threejs_example_container">
  <iframe class="threejs_example" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-lights-ambient.html"></iframe>
  <a class="threejs_center" href="/threejs/lessons/../threejs-lights-ambient.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>Click and drag in the scene to <em>orbit</em> the camera.</p>
<p>Notice there is no defintion. The shapes are flat. The <code>AmbientLight</code> effectively
just multiply&#39;s the material&#39;s color by the light&#39;s color times the
intensity.</p>
<pre><code>color = materialColor * light.color * light.intensity;
</code></pre><p>That&#39;s it. It has no direction. 
This style of ambient lighting is actually not all that
useful as lighting as it&#39;s 100% even so other than changing the color
of everything in the scene it doesn&#39;t look much like <em>lighting</em>.
What it does help with is making the darks not too dark.</p>
<h2 id="-hemispherelight-"><code>HemisphereLight</code></h2>
<p>Let&#39;s switch the code the a <code>HemisphereLight</code>. A <code>HemisphereLight</code>
takes a sky color and a ground color and just multplies the
material&#39;s color between those 2 colors. The sky color if the
surface of the object is pointing up and the ground color if
the surface of the object is pointing down.</p>
<p>Here&#39;s the new code</p>
<pre><code class="lang-javascript">-const color = 0xFFFFFF;
+const skyColor = 0xB1E1FF;  // light blue
+const groundColor = 0xB97A20;  // brownish orange
const intensity = 1;
-const light = new THREE.AmbientLight(color, intensity);
+const light = new THREE.HemisphereLight(skyColor, groundColor, intensity);
scene.add(light);
</code></pre>
<p>Let&#39;s also update the dat.GUI code to edit both colors</p>
<pre><code class="lang-javascript">const gui = new dat.GUI();
-gui.addColor(new ColorGUIHelper(light, &#39;color&#39;), &#39;value&#39;).name(&#39;color&#39;);
+gui.addColor(new ColorGUIHelper(light, &#39;color&#39;), &#39;value&#39;).name(&#39;skyColor&#39;);
+gui.addColor(new ColorGUIHelper(light, &#39;groundColor&#39;), &#39;value&#39;).name(&#39;groundColor&#39;);
gui.add(light, &#39;intensity&#39;, 0, 2);
</code></pre>
<p>The result:</p>
<p><div class="threejs_example_container">
  <iframe class="threejs_example" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-lights-hemisphere.html"></iframe>
  <a class="threejs_center" href="/threejs/lessons/../threejs-lights-hemisphere.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>Notice again there is almost no defintion, everything looks kind
of flat. The <code>HemisphereLight</code> used in combination with another light
can help give a nice kind of influence of the color of the sky
and ground. In that way it&#39;s best used in combination with some
other light or a substitute for an <code>AmbientLight</code>.</p>
<h2 id="-directionallight-"><code>DirectionalLight</code></h2>
<p>Let&#39;s switch the code to a <code>DirectionalLight</code>.
A <code>DirectionalLight</code> is often used to represent the sun.</p>
<pre><code class="lang-javascript">const color = 0xFFFFFF;
const intensity = 1;
const light = new THREE.DirectionalLight(color, intensity);
light.position.set(0, 10, 0);
light.target.position.set(-5, 0, 0);
scene.add(light);
scene.add(light.target);
</code></pre>
<p>Notice that we had to add the <code>light</code> and the <code>light.target</code>
to the scene. A three.js <code>DirectionalLight</code> will shine
in the direction of its target.</p>
<p>Let&#39;s make it so we can move the target by adding it to
our GUI.</p>
<pre><code class="lang-javascript">const gui = new dat.GUI();
gui.addColor(new ColorGUIHelper(light, &#39;color&#39;), &#39;value&#39;).name(&#39;color&#39;);
gui.add(light, &#39;intensity&#39;, 0, 2);
gui.add(light.target.position, &#39;x&#39;, -10, 10);
gui.add(light.target.position, &#39;z&#39;, -10, 10);
gui.add(light.target.position, &#39;y&#39;, 0, 10);
</code></pre>
<p><div class="threejs_example_container">
  <iframe class="threejs_example" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-lights-directional.html"></iframe>
  <a class="threejs_center" href="/threejs/lessons/../threejs-lights-directional.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>It&#39;s kind of hard to see what&#39;s going on. Three.js has a bunch
of helper objects we can add to our scene to help visualize
invisible parts of a scene. In this case we&#39;ll use the
<code>DirectionalLightHelper</code> which will draw a plane, to represent
the light, and a line from the light to the target. We just
pass it the light and add itd add it to the scene.</p>
<pre><code class="lang-javascript">const helper = new THREE.DirectionalLightHelper(light);
scene.add(helper);
</code></pre>
<p>While we&#39;re at it lets make it so we can set both the position
of the light and the target. To do this we&#39;ll make a function
that given a <code>Vector3</code> will adjust its <code>x</code>, <code>y</code>, and <code>z</code> properties
using <code>dat.GUI</code>.</p>
<pre><code class="lang-javascript">function makeXYZGUI(gui, vector3, name, onChangeFn) {
  const folder = gui.addFolder(name);
  folder.add(vector3, &#39;x&#39;, -10, 10).onChange(onChangeFn);
  folder.add(vector3, &#39;y&#39;, 0, 10).onChange(onChangeFn);
  folder.add(vector3, &#39;z&#39;, -10, 10).onChange(onChangeFn);
  folder.open();
}
</code></pre>
<p>Note that we need to call the helper&#39;s <code>update</code> function
anytime we change something so the helper knows to update
itself. As such we pass in an <code>onChangeFn</code> function to
get called anytime dat.GUI updates a value.</p>
<p>Then we can use that for both the light&#39;s position
and the target&#39;s position like this</p>
<pre><code class="lang-javascript">+const onChange = () =&gt; {
+  light.target.updateMatrixWorld();
+  helper.update();
+};
+onChange();

const gui = new dat.GUI();
gui.addColor(new ColorGUIHelper(light, &#39;color&#39;), &#39;value&#39;).name(&#39;color&#39;);
gui.add(light, &#39;intensity&#39;, 0, 2);

+makeXYZGUI(gui, light.position, &#39;position&#39;, onChange);
+makeXYZGUI(gui, light.target.position, &#39;target&#39;, onChange);
</code></pre>
<p>Now we can move the light, and its target</p>
<p><div class="threejs_example_container">
  <iframe class="threejs_example" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-lights-directional-w-helper.html"></iframe>
  <a class="threejs_center" href="/threejs/lessons/../threejs-lights-directional-w-helper.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>Orbit the camera and it gets easier to see. The plane
represents a <code>DirectionalLight</code> because a directional
light computes light comming in one direction. There is no
<em>point</em> the light comes from, it&#39;s an infinite plane of light
shooting out parallel rays of light.</p>
<h2 id="-pointlight-"><code>PointLight</code></h2>
<p>A <code>PointLight</code> is a light that sits at a point and shoots light
in all directions from that point. Let&#39;s change the code.</p>
<pre><code class="lang-javascript">const color = 0xFFFFFF;
const intensity = 1;
-const light = new THREE.DirectionalLight(color, intensity);
+const light = new THREE.PointLight(color, intensity);
light.position.set(0, 10, 0);
-light.target.position.set(-5, 0, 0);
scene.add(light);
-scene.add(light.target);
</code></pre>
<p>Let&#39;s also switch to a <code>PointLightHelper</code></p>
<pre><code class="lang-javascript">-const helper = new THREE.DirectionalLightHelper(light);
+const helper = new THREE.PointLightHelper(light);
scene.add(helper);
</code></pre>
<p>and as there is no target the <code>onChange</code> function can be simpler.</p>
<pre><code class="lang-javascript">-const onChange = () =&gt; {
-  light.target.updateMatrixWorld();
-  helper.update();
-};
-onChange();
+const onChange = helper.update.bind(helper);
</code></pre>
<p>Note that at some level a <code>PointLightHelper</code> has no um, point.
It just draws a small wireframe diamond. It could just as easily
be any shape you want, just add a mesh to the light itself.</p>
<p>A <code>PointLight</code> has the added property of <a href="PointLight.distance"><code>distance</code></a>.
If the <code>distance</code> is 0 then the <code>PointLight</code> shines to
infinity. If the <code>distance</code> is greater than 0 then the light shines
its full intensity at the light and fades to no influnce at <code>distance</code>
units away from the light.</p>
<p>Let&#39;s setup the GUI so we can adjust the distance.</p>
<pre><code class="lang-javascript">const gui = new dat.GUI();
gui.addColor(new ColorGUIHelper(light, &#39;color&#39;), &#39;value&#39;).name(&#39;color&#39;);
gui.add(light, &#39;intensity&#39;, 0, 2);
+gui.add(light, &#39;distance&#39;, 0, 40).onChange(onChange);

makeXYZGUI(gui, light.position, &#39;position&#39;, onChange);
-makeXYZGUI(gui, light.target.position, &#39;target&#39;, onChange);
</code></pre>
<p>And now try it out.</p>
<p><div class="threejs_example_container">
  <iframe class="threejs_example" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-lights-point.html"></iframe>
  <a class="threejs_center" href="/threejs/lessons/../threejs-lights-point.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>Notice when <code>distance</code> is &gt; 0 how the light fades out.</p>
<h2 id="-spotlight-"><code>SpotLight</code></h2>
<p>Spotlights are affectively a point light with a cone
attached where the light only shines inside the cone.
There&#39;s actually 2 cones. An outer cone and an inner
cone. Between the inner cone and the outer cone the
light fades from full intensity to zero.</p>
<p>To use a <code>SpotLight</code> we need a target just like
the directional light. The light&#39;s cone will
open toward the target.</p>
<p>Modifying our <code>DirectionalLight</code> with helper from above</p>
<pre><code class="lang-javascript">const color = 0xFFFFFF;
const intensity = 1;
-const light = new THREE.DirectionalLight(color, intensity);
+const light = new THREE.SpotLight(color, intensity);
scene.add(light);
scene.add(light.target);

-const helper = new THREE.DirectionalLightHelper(light);
+const helper = new THREE.SpotLightHelper(light);
scene.add(helper);
</code></pre>
<p>The spotlight&#39;s cone&#39;s angle is set with the <a href="Spotlight.angle"><code>angle</code></a>
property in radians. We&#39;ll use our <code>DegRadHelper</code> from the 
<a href="threejs-textures.html">texture artcle</a> to present a UI in
degrees.</p>
<pre><code class="lang-javascript">gui.add(new DegRadHelper(light, &#39;angle&#39;), &#39;value&#39;, 0, 90).name(&#39;angle&#39;).onChange(onChange);
</code></pre>
<p>The inner cone is defined by setting the <a href="SpotLight.penumbra"><code>penumbra</code></a> property
as a percentage from the outer cone. In other words when <code>penumbra</code> is 0 then the
inner code is the same size (0 = no difference) from the outer cone. When the
<code>penumbra</code> is 1 then the light fades starting in the center of the cone to the
outer cone. When <code>penumbra</code> is .5 then the light fades starting from 50% between
the center of the outer cone.</p>
<pre><code class="lang-javascript">gui.add(light, &#39;penumbra&#39;, 0, 1);
</code></pre>
<p><div class="threejs_example_container">
  <iframe class="threejs_example" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-lights-spot-w-helper.html"></iframe>
  <a class="threejs_center" href="/threejs/lessons/../threejs-lights-spot-w-helper.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>Notice with the default <code>penumbra</code> of 0 the spotlight has a very sharp edge
where as as you adjust the <code>penumbra</code> toward 1 edge blurs.</p>
<p>It might be hard to see the <em>cone</em> of the spotlight. The reason is it&#39;s
below the ground. Shorten the distance to around 5 and you&#39;ll see the open
end of the cone.</p>
<h2 id="-rectarealight-"><code>RectAreaLight</code></h2>
<p>There&#39;s one more type of light, the <code>RectAreaLight</code>, which represents
exactly what it sounds like, a rectangular area of light like a long
fluorescent light or maybe a frosted sky light in a ceiling.</p>
<p>The <code>RectAreaLight</code> only works with the <code>MeshStandardMaterai</code> and the
<code>MeshPhysicalMaterial</code> so let&#39;s change all our materials to <code>MeshStandardMaterial</code></p>
<pre><code class="lang-javascript">  ...

  const planeGeo = new THREE.PlaneBufferGeometry(planeSize, planeSize);
-  const planeMat = new THREE.MeshPhongMaterial({
+  const planeMat = new THREE.MeshStandardMaterial({
    map: texture,
    side: THREE.DoubleSide,
  });
  const mesh = new THREE.Mesh(planeGeo, planeMat);
  mesh.rotation.x = Math.PI * -.5;
  scene.add(mesh);
}
{
  const cubeSize = 4;
  const cubeGeo = new THREE.BoxBufferGeometry(cubeSize, cubeSize, cubeSize);
- const cubeMat = new THREE.MeshPhongMaterial({color: &#39;#8AC&#39;});
+ const cubeMat = new THREE.MeshStandardMaterial({color: &#39;#8AC&#39;});
  const mesh = new THREE.Mesh(cubeGeo, cubeMat);
  mesh.position.set(cubeSize + 1, cubeSize / 2, 0);
  scene.add(mesh);
}
{
  const sphereRadius = 3;
  const sphereWidthDivisions = 32;
  const sphereHeightDivisions = 16;
  const sphereGeo = new THREE.SphereBufferGeometry(sphereRadius, sphereWidthDivisions, sphereHeightDivisions);
-  const sphereMat = new THREE.MeshPhongMaterial({color: &#39;#CA8&#39;});
+ const sphereMat = new THREE.MeshStandardMaterial({color: &#39;#CA8&#39;});
  const mesh = new THREE.Mesh(sphereGeo, sphereMat);
  mesh.position.set(-sphereRadius - 1, sphereRadius + 2, 0);
  scene.add(mesh);
}
</code></pre>
<p>To use the <code>RectAreaLight</code> we need to include some extra three.js optional data</p>
<pre><code class="lang-html">&lt;script src=&quot;resources/threejs/r94/three.min.js&quot;&gt;&lt;/script&gt;
+&lt;script src=&quot;resources/threejs/r94/js/lights/RectAreaLightUniformsLib.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>If you forget the data the light will still work but it will look funny so
be sure to remember to include the extra data.</p>
<p>Now we can create the light</p>
<pre><code class="lang-javascript">const color = 0xFFFFFF;
*const intensity = 5;
+const width = 12;
+const height = 4;
*const light = new THREE.RectAreaLight(color, intensity, width, height);
light.position.set(0, 10, 0);
+light.rotation.x = THREE.Math.degToRad(30);
scene.add(light);

*const helper = new THREE.RectAreaLightHelper(light);
scene.add(helper);
</code></pre>
<p>One thing to notice is that unlike the <code>DirectionalLight</code> and the <code>SpotLight</code> the
<code>RectAreaLight</code> does not use a target. It just uses its rotation.</p>
<p>Let&#39;s also adjust the GUI. We&#39;ll make it so we can rotate the light and adjust
its <code>width</code> and <code>height</code></p>
<pre><code class="lang-javascript">const gui = new dat.GUI();
gui.addColor(new ColorGUIHelper(light, &#39;color&#39;), &#39;value&#39;).name(&#39;color&#39;);
gui.add(light, &#39;intensity&#39;, 0, 10);
gui.add(light, &#39;width&#39;, 0, 20).onChange(onChange);
gui.add(light, &#39;height&#39;, 0, 20).onChange(onChange);
gui.add(new DegRadHelper(light.rotation, &#39;x&#39;), &#39;value&#39;, -180, 180).name(&#39;x rotation&#39;).onChange(onChange);
gui.add(new DegRadHelper(light.rotation, &#39;y&#39;), &#39;value&#39;, -180, 180).name(&#39;y rotation&#39;).onChange(onChange);
gui.add(new DegRadHelper(light.rotation, &#39;z&#39;), &#39;value&#39;, -180, 180).name(&#39;z rotation&#39;).onChange(onChange);

makeXYZGUI(gui, light.position, &#39;position&#39;, onChange);
</code></pre>
<p>And here is that.</p>
<p><div class="threejs_example_container">
  <iframe class="threejs_example" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-lights-rectarea.html"></iframe>
  <a class="threejs_center" href="/threejs/lessons/../threejs-lights-rectarea.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>One thing we didn&#39;t cover is that there is a setting on the <code>WebGLRenderer</code>
called <code>physicallyCorrectLights</code>. It effects how light falls off as distance from light.
It only affects <code>PointLight</code> and <code>SpotLight</code>. <code>RectAreaLight</code> does this automatically.</p>
<p>For lights though the basic idea is you don&#39;t set a distance for them to fade out, 
and you don&#39;t set <code>intensity</code>. Instead you set the <a href="PointLight.power"><code>power</code></a> of 
the light in lumens and then three.js will use physics calculations like real lights. 
The units of three.js in this case are meters and a 60w light bulb would have 
around 800 lumens. There&#39;s also a <a href="PointLight.decay"><code>decay</code></a> property. It should
be set to <code>2</code> for realistic decay.</p>
<p>Let&#39;s test that.</p>
<p>First we&#39;ll turn on physically correct lights</p>
<pre><code class="lang-javascript">const renderer = new THREE.WebGLRenderer({canvas: canvas});
+renderer.physicallyCorrectLights = true;
</code></pre>
<p>Then we&#39;ll set the <code>power</code> to 800 lumens, the <code>decay</code> to 2, and
the <code>distance</code> to <code>Infinity</code>.</p>
<pre><code class="lang-javascript">const color = 0xFFFFFF;
const intensity = 1;
const light = new THREE.PointLight(color, intensity);
light.power = 800;
light.decay = 2;
light.distance = Infinity;
</code></pre>
<p>and we&#39;ll add gui so we can change the <code>power</code> and <code>decay</code></p>
<pre><code class="lang-javascript">const gui = new dat.GUI();
gui.addColor(new ColorGUIHelper(light, &#39;color&#39;), &#39;value&#39;).name(&#39;color&#39;);
gui.add(light, &#39;decay&#39;, 0, 4);
gui.add(light, &#39;power&#39;, 0, 2000);
</code></pre>
<p><div class="threejs_example_container">
  <iframe class="threejs_example" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-lights-point-physically-correct.html"></iframe>
  <a class="threejs_center" href="/threejs/lessons/../threejs-lights-point-physically-correct.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>It&#39;s important to note each light you add to scene slows down how fast
three.js renders the scene so you should always try to use as few as
possible to achieve your goals. </p>
<p>Next up let&#39;s go over <a href="threejs-shadows.html">how to render shadows</a>.</p>
<p><canvas id="c"></canvas></p>
<script src="../resources/threejs/r94/three.min.js"></script>
<script src="../resources/threejs/r94/js/controls/OrbitControls.js"></script>
<script src="resources/threejs-lesson-utils.js"></script>
<script src="resources/threejs-lights.js"></script>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/threejs/lessons/threejs-lights.html" selected>English</a>
</select>


        <div id="toc">
          <ul>
  <li>Fundamentals</li>
  <ul>
    <li><a href="/threejs/lessons/threejs-fundamentals.html">Fundamentals</a></li>
    <li><a href="/threejs/lessons/threejs-responsive.html">Responsive Design</a></li>
    <li><a href="/threejs/lessons/threejs-primitives.html">Primitives</a></li>
    <li><a href="/threejs/lessons/threejs-scenegraph.html">Scenegraph</a></li>
    <li><a href="/threejs/lessons/threejs-materials.html">Materials</a></li>
    <li><a href="/threejs/lessons/threejs-setup.html">Setup</a></li>
    <li><a href="/threejs/lessons/threejs-textures.html">Textures</a></li>
    <li><a href="/threejs/lessons/threejs-lights.html">Lights</a></li>
    <li><a href="/threejs/lessons/threejs-fog.html">Fog</a></li>
  </ul>
  <li>Reference</li>
  <ul>
    <li><a href="/threejs/lessons/threejs-prerequisites.html">Prerequisites</a></li>
    <li><a href="/threejs/lessons/threejs-material-table.html">Material Table</a></li>
  </ul>
</ul>
<ul>
  <li><a href="https://github.com/greggman/threejsfundamentals">github</a></li>
  <li><a href="https://threejs.org">three.js</a></li>
  <li><a href="https://threejs.org/docs/">three.js docs</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        <div>Questions? <a href="http://stackoverflow.com/questions/tagged/three.js">Ask on stackoverflow</a>.</div>
        <div>Issue/Bug? <a href="http://github.com/greggman/threejsfundamentals/issues">Create an issue on github</a>.</div>

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'threejsfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'Three.js Lights';
            var disqus_title = 'Three.js Lights';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("threejsfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/threejs/lessons/resources/prettify.js"></script>
<script src="/threejs/lessons/resources/lesson.js"></script>
<script src="//cdn.webglstats.com/stat.js" defer="defer" async="async"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-120733518-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-120733518-1');
</script>


</html>



