<!DOCTYPE html><!-- this file is auto-generated from threejs/lessons/ja/threejs-picking.md. Do not edited directly --><!--
Copyright 2018, Google Inc.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of Google Inc. nor the names of their
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
--><html lang="ja"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Three.jsでマウスからオブジェクトを選択する">
<meta name="keywords" content="webgl graphics three.js">
<meta name="thumbnail" content="https://threejsfundamentals.org/threejs/lessons/screenshots/threejs-picking_ja.jpg">

<meta property="og:title" content="Three.jsでピッキング">
<meta property="og:type" content="website">
<meta property="og:image" content="https://threejsfundamentals.org/threejs/lessons/screenshots/threejs-picking_ja.jpg">
<meta property="og:description" content="Three.jsでマウスからオブジェクトを選択する">
<meta property="og:url" content="https://threejsfundamentals.org/threejs/lessons/ja/threejs-picking.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="threejsfundamentals.org">
<meta name="twitter:title" content="Three.jsでピッキング">
<meta name="twitter:url" content="https://threejsfundamentals.org/threejs/lessons/ja/threejs-picking.html">
<meta name="twitter:description" content="Three.jsでマウスからオブジェクトを選択する">
<meta name="twitter:image:src" content="https://threejsfundamentals.org/threejs/lessons/screenshots/threejs-picking_ja.jpg">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/threejs/lessons/threejs-picking.html">
  <link rel="alternate" hreflang="fr" href="https://webglfundamentals.org/threejs/lessons/fr/threejs-picking.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/threejs/lessons/ja/threejs-picking.html">
  <link rel="alternate" hreflang="kr" href="https://webglfundamentals.org/threejs/lessons/kr/threejs-picking.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/threejs/lessons/ru/threejs-picking.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/threejs/lessons/zh_cn/threejs-picking.html">




<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://threejsfundamentals.org/#website",
      "url":"https://threejsfundamentals.org/",
      "name":"ThreejsFundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://threejsfundamentals.org/threejs/lessons/ja/threejs-picking.html#primaryimage",
      "url":"https://threejsfundamentals.org/threejs/lessons/screenshots/threejs-picking_ja.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://threejsfundamentals.org/threejs/lessons/ja/threejs-picking.html#webpage",
      "url":"https://threejsfundamentals.org/threejs/lessons/ja/threejs-picking.html",
      "inLanguage":"ja",
      "name":"Three.jsでピッキング",
      "keywords":"webgl graphics three.js programming",
      "isPartOf":{
        "@id":"https://threejsfundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://threejsfundamentals.org/threejs/lessons/ja/threejs-picking.html#primaryimage"
      }
    }
  ]
}
</script>

<title>Three.jsでピッキング</title>
<link href="/threejs/lessons/resources/threejsfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/threejs/lessons/resources/threejsfundamentals-icon.png">
<link rel="icon" href="/threejs/lessons/resources/threejsfundamentals-icon.png">

<link rel="stylesheet" href="/threejs/lessons/lang.css">
<link rel="stylesheet" href="/threejs/lessons/resources/lesson.css">
</head>
<body>
<div class="threejs_navbar">
  <div>
    <select class="language">
    <option value="/threejs/lessons/threejs-picking.html">English
    </option><option value="/threejs/lessons/fr/threejs-picking.html">Français
    </option><option value="/threejs/lessons/ja/threejs-picking.html" selected="">日本語
    </option><option value="/threejs/lessons/kr/threejs-picking.html">한국어
    </option><option value="/threejs/lessons/ru/threejs-picking.html">Русский
    </option><option value="/threejs/lessons/zh_cn/threejs-picking.html">中文
</option></select>


    <a href="#toc">目次</a>
  </div>
</div>
<div class="threejs_header">
  <h1><a href="/threejs/lessons/ja/">threejsfundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/threejsfundamentals">Fix, Fork, Contribute <!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"></path>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>Three.jsでピッキング</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p><em>ピッキング</em>とはユーザーがどのオブジェクトをクリックしたか、またはタッチしたかを把握するプロセスの事です。
ピッキングする方法のそれぞれにトレードオフがありますが、実装の仕方はたくさんあります。最も一般的な2つの方法を見てみましょう。</p>
<p>おそらく、最も一般的な<em>ピッキング</em>はレイキャスティングでマウスからシーンの錐台を通して光線を<em>キャスト</em>し、その光線が交差するオブジェクトを計算する方法です。
概念的には非常にシンプルです。</p>
<p>まずはマウスの位置を決めます。
それをカメラの投影と向きをワールド座標に変換します。
カメラの錐台の近くの面から遠くの面までの光線を計算します。
そして、シーン内の全ての三角形オブジェクトで光線と交差するかチェックします。
もしシーンに1000個のオブジェクトがあり、各オブジェクトに1000個の三角形がある場合、100万個の三角形をチェックする必要があります。</p>
<p>光線がオブジェクトのバウンディングスフィアやバウンディングボックス、つまりオブジェクト全体を含む球やボックスと交差するかを最初にチェックする事は最適化になります。
もし光線がオブジェクトと交差しなければ、そのオブジェクトの三角形をチェックする必要はありません。</p>
<p>Three.jsにはこれを行う <code class="notranslate" translate="no">RayCaster</code> クラスを提供しています。</p>
<p>100個のオブジェクトがあるシーンを作ってピッキングしてみましょう。
<a href="threejs-responsive.html">レスポンシブデザインの記事</a>のコード例から始めてみます。</p>
<p>いくつかの変更点</p>
<p>カメラを別のオブジェクトの親にして、そのオブジェクトを回転させるとカメラが自撮り棒のようにシーンの周りを動き回るようになります。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">*const fov = 60;
const aspect = 2;  // the canvas default
const near = 0.1;
*const far = 200;
const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
*camera.position.z = 30;

const scene = new THREE.Scene();
+scene.background = new THREE.Color('white');

+// put the camera on a pole (parent it to an object)
+// so we can spin the pole to move the camera around the scene
+const cameraPole = new THREE.Object3D();
+scene.add(cameraPole);
+cameraPole.add(camera);
</pre>
<p>そして、<code class="notranslate" translate="no">render</code> 関数でcameraPoleを回転させます。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">cameraPole.rotation.y = time * .1;
</pre>
<p>カメラにライトを追加し、ライトが動くようにしましょう。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-scene.add(light);
+camera.add(light);
</pre>
<p>ランダムな色、位置、向き、スケールの100個のキューブを生成してみましょう。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const boxWidth = 1;
const boxHeight = 1;
const boxDepth = 1;
const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);

function rand(min, max) {
  if (max === undefined) {
    max = min;
    min = 0;
  }
  return min + (max - min) * Math.random();
}

function randomColor() {
  return `hsl(${rand(360) | 0}, ${rand(50, 100) | 0}%, 50%)`;
}

const numObjects = 100;
for (let i = 0; i &lt; numObjects; ++i) {
  const material = new THREE.MeshPhongMaterial({
    color: randomColor(),
  });

  const cube = new THREE.Mesh(geometry, material);
  scene.add(cube);

  cube.position.set(rand(-20, 20), rand(-20, 20), rand(-20, 20));
  cube.rotation.set(rand(Math.PI), rand(Math.PI), 0);
  cube.scale.set(rand(3, 6), rand(3, 6), rand(3, 6));
}
</pre>
<p>最後にピックします。</p>
<p>ピッキングを管理する簡単なクラスを作ってみましょう。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">class PickHelper {
  constructor() {
    this.raycaster = new THREE.Raycaster();
    this.pickedObject = null;
    this.pickedObjectSavedColor = 0;
  }
  pick(normalizedPosition, scene, camera, time) {
    // restore the color if there is a picked object
    if (this.pickedObject) {
      this.pickedObject.material.emissive.setHex(this.pickedObjectSavedColor);
      this.pickedObject = undefined;
    }

    // cast a ray through the frustum
    this.raycaster.setFromCamera(normalizedPosition, camera);
    // get the list of objects the ray intersected
    const intersectedObjects = this.raycaster.intersectObjects(scene.children);
    if (intersectedObjects.length) {
      // pick the first object. It's the closest one
      this.pickedObject = intersectedObjects[0].object;
      // save its color
      this.pickedObjectSavedColor = this.pickedObject.material.emissive.getHex();
      // set its emissive color to flashing red/yellow
      this.pickedObject.material.emissive.setHex((time * 8) % 2 &gt; 1 ? 0xFFFF00 : 0xFF0000);
    }
  }
}
</pre>
<p><code class="notranslate" translate="no">RayCaster</code> を作成し、<code class="notranslate" translate="no">pick</code> 関数を呼び出してシーンに光線をキャストできます。
光線が何かに当たった場合、最初に当たったオブジェクトの色を変更します。</p>
<p>もちろん、マウスを <em>down</em> した時だけこの関数を呼べますが、今回は全てのフレームでマウスの下に何かあるかピックします。
そのためにはまずマウスがどこにあるかを追跡する必要があります。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const pickPosition = {x: 0, y: 0};
clearPickPosition();

...

function getCanvasRelativePosition(event) {
  const rect = canvas.getBoundingClientRect();
  return {
    x: (event.clientX - rect.left) * canvas.width  / rect.width,
    y: (event.clientY - rect.top ) * canvas.height / rect.height,
  };
}

function setPickPosition(event) {
  const pos = getCanvasRelativePosition(event);
  pickPosition.x = (pos.x / canvas.width ) *  2 - 1;
  pickPosition.y = (pos.y / canvas.height) * -2 + 1;  // note we flip Y
}

function clearPickPosition() {
  // unlike the mouse which always has a position
  // if the user stops touching the screen we want
  // to stop picking. For now we just pick a value
  // unlikely to pick something
  pickPosition.x = -100000;
  pickPosition.y = -100000;
}

window.addEventListener('mousemove', setPickPosition);
window.addEventListener('mouseout', clearPickPosition);
window.addEventListener('mouseleave', clearPickPosition);
</pre>
<p>正規化されたマウスの位置を記録している事に注意して下さい。
キャンバスの大きさに関わらず、leftの-1からrightの+1までの値が必要です。
同様にbottomが-1からtopが+1になるような値が必要です。</p>
<p>これでモバイル端末もサポートできます。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">window.addEventListener('touchstart', (event) =&gt; {
  // prevent the window from scrolling
  event.preventDefault();
  setPickPosition(event.touches[0]);
}, {passive: false});

window.addEventListener('touchmove', (event) =&gt; {
  setPickPosition(event.touches[0]);
});

window.addEventListener('touchend', clearPickPosition);
</pre>
<p>最後に <code class="notranslate" translate="no">render</code> 関数で <code class="notranslate" translate="no">PickHelper</code> の <code class="notranslate" translate="no">pick</code> 関数を呼び出します。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+const pickHelper = new PickHelper();

function render(time) {
  time *= 0.001;  // convert to seconds;

  ...

+  pickHelper.pick(pickPosition, scene, camera, time);

  renderer.render(scene, camera);

  ...
</pre>
<p>その結果がこれです。</p>
<p></p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-picking-raycaster.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-picking-raycaster.html" target="_blank">ここをクリックして別のウィンドウで開きます</a>
</div>

<p></p>
<p>望んだ動作でおそらく多くのユースケースに対応できますが、いくつか問題点があります。</p>
<ol>
<li><p>CPUベース</p>
<p>JavaScriptは各オブジェクトを通過し、光線がそのオブジェクトのバウンディングボックス、またはバウンディングスフィアと交差するかをチェックしています。
そのオブジェクト内の各三角形を通過し、光線が三角形と交差するかチェックしなければなりません。</p>
<p>これの良い点はJavaScriptが簡単に光線が三角形と交差する場所を正確に計算し、その結果が分かります。
例えば交差する点があった場所に目印をつけたい場合などです。</p>
<p>悪い点はCPUの負担が大きい所ですね。
三角形がたくさんあるオブジェクトを持っている場合は遅いかもしれません。</p>
</li>
<li><p>変なシェーダーやズレを処理しません</p>
<p>ジオメトリを変形またはモーフィングするシェーダーがある場合、JavaScriptはその変形を認識できなく、間違った答えを返してしまいます。
例えばAFAIKのように、メソッドはスキニングされたオブジェクトでは使えません。</p>
</li>
<li><p>透明な穴には対応しません</p>
</li>
</ol>
<p>例として、このテクスチャをキューブに適用してみましょう。</p>
<div class="threejs_center"><img class="checkerboard" src="../../resources/images/frame.png"></div>

<p>以下のように変更します。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+const loader = new THREE.TextureLoader();
+const texture = loader.load('resources/images/frame.png');

const numObjects = 100;
for (let i = 0; i &lt; numObjects; ++i) {
  const material = new THREE.MeshPhongMaterial({
    color: randomColor(),
    +map: texture,
    +transparent: true,
    +side: THREE.DoubleSide,
    +alphaTest: 0.1,
  });

  const cube = new THREE.Mesh(geometry, material);
  scene.add(cube);

  ...
</pre>
<p>以下の例で動作確認をすると、すぐにこの問題が分かると思います。</p>
<p></p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-picking-raycaster-transparency.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-picking-raycaster-transparency.html" target="_blank">ここをクリックして別のウィンドウで開きます</a>
</div>

<p></p>
<p>ボックスの穴の部分でピックしてみて下さい。</p>
<div class="threejs_center"><img src="../resources/images/picking-transparent-issue.jpg" style="width: 635px;"></div>

<p>この原因は、JavaScriptがテクスチャやマテリアルを調べて、オブジェクトの一部が本当に透明か判断できないからです。</p>
<p>これらの問題を全て解決するのが、GPUベースのピッキングです。
概念的には簡単ですが、残念ながら上記のレイキャスティングよりも使用方法が複雑になっています。</p>
<p>GPUピッキングを行うには、各オブジェクトをオフスクリーンでユニークな色でレンダリングします。
次にマウスの位置に対応するピクセルの色を調べます。
色でどのオブジェクトが選ばれたか分かります。</p>
<p>これで上記の2と3の問題を解決できます。問題1は速度に依存しています。
全てのオブジェクトは2回描画されなければなりません。
1回は見るための描画、もう1回はピッキングの描画です。
洗練された解決策は、その両方を同時に行う事ですが今回はそれを試しません。</p>
<p>1つのやり方としては、1つのピクセルしか読まないのでそのピクセルだけ描画されるようにカメラを設定します。
これを行うには <a href="https://threejs.org/docs/#api/en/cameras/PerspectiveCamera.setViewOffset"><code class="notranslate" translate="no">PerspectiveCamera.setViewOffset</code></a> を使用します。
これでカメラを計算できます。
これで時間を節約できるはずです。</p>
<p>現時点ではこのピッキングを行うには、2つのシーンを作成する必要があります。
1つは通常のメッシュで埋めます。
もう1つはピッキングマテリアルを使用したメッシュで埋めます。</p>
<p>そこでまず2つ目のシーンを作り黒でクリアします。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const scene = new THREE.Scene();
scene.background = new THREE.Color('white');
const pickingScene = new THREE.Scene();
pickingScene.background = new THREE.Color(0);
</pre>
<p>次にメインシーンに配置する各キューブでオリジナルのキューブと同じ位置に対応する"ピッキングキューブ"を作成し、<code class="notranslate" translate="no">pickingScene</code> に配置します。
オブジェクトのidを色として描画するようにマテリアルを設定します。
また、idとオブジェクトのマップがあるので、後でidを調べた時に対応するオブジェクトにマップを戻す事ができます。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const idToObject = {};
+const numObjects = 100;
for (let i = 0; i &lt; numObjects; ++i) {
+  const id = i + 1;
  const material = new THREE.MeshPhongMaterial({
    color: randomColor(),
    map: texture,
    transparent: true,
    side: THREE.DoubleSide,
    alphaTest: 0.1,
  });

  const cube = new THREE.Mesh(geometry, material);
  scene.add(cube);
+  idToObject[id] = cube;

  cube.position.set(rand(-20, 20), rand(-20, 20), rand(-20, 20));
  cube.rotation.set(rand(Math.PI), rand(Math.PI), 0);
  cube.scale.set(rand(3, 6), rand(3, 6), rand(3, 6));

+  const pickingMaterial = new THREE.MeshPhongMaterial({
+    emissive: new THREE.Color(id),
+    color: new THREE.Color(0, 0, 0),
+    specular: new THREE.Color(0, 0, 0),
+    map: texture,
+    transparent: true,
+    side: THREE.DoubleSide,
+    alphaTest: 0.5,
+    blending: THREE.NoBlending,
+  });
+  const pickingCube = new THREE.Mesh(geometry, pickingMaterial);
+  pickingScene.add(pickingCube);
+  pickingCube.position.copy(cube.position);
+  pickingCube.rotation.copy(cube.rotation);
+  pickingCube.scale.copy(cube.scale);
}
</pre>
<p>ここでは <a href="https://threejs.org/docs/#api/en/materials/MeshPhongMaterial"><code class="notranslate" translate="no">MeshPhongMaterial</code></a> を悪用している事に注意して下さい。
<code class="notranslate" translate="no">emissive</code> をidにし、<code class="notranslate" translate="no">color</code> と <code class="notranslate" translate="no">specular</code> を0に設定しテクスチャのアルファ値が <code class="notranslate" translate="no">alphaTest</code> よりも大きい場合にのみ、idをレンダリングできます。
また、<code class="notranslate" translate="no">blending</code> を <code class="notranslate" translate="no">NoBlending</code> に設定し、idにアルファが乗算しないようにする必要があります。</p>
<p><a href="https://threejs.org/docs/#api/en/materials/MeshPhongMaterial"><code class="notranslate" translate="no">MeshPhongMaterial</code></a>を悪用する事は、最良の解決策でない事に注意して下さい。
さらに最適化された解決策は、テクスチャのアルファ値が <code class="notranslate" translate="no">alphaTest</code> よりも大きい場合にidを書き込むカスタムシェーダーを作成する事です。</p>
<p>レイキャスティングではなくピクセルからピックしているので、ピック位置を設定するコードを変更してピクセルだけを使用できます。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">function setPickPosition(event) {
  const pos = getCanvasRelativePosition(event);
-  pickPosition.x = (pos.x / canvas.clientWidth ) *  2 - 1;
-  pickPosition.y = (pos.y / canvas.clientHeight) * -2 + 1;  // note we flip Y
+  pickPosition.x = pos.x;
+  pickPosition.y = pos.y;
}
</pre>
<p><code class="notranslate" translate="no">PickHelper</code> を <code class="notranslate" translate="no">GPUPickHelper</code> に変更してみましょう。
<a href="threejs-rendertargets.html">レンダーターゲットの記事</a>で説明したように <a href="https://threejs.org/docs/#api/en/renderers/WebGLRenderTarget"><code class="notranslate" translate="no">WebGLRenderTarget</code></a> を使います。
ここでのレンダーターゲットは1 x 1の1ピクセルのサイズしかありません。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-class PickHelper {
+class GPUPickHelper {
  constructor() {
-    this.raycaster = new THREE.Raycaster();
+    // create a 1x1 pixel render target
+    this.pickingTexture = new THREE.WebGLRenderTarget(1, 1);
+    this.pixelBuffer = new Uint8Array(4);
    this.pickedObject = null;
    this.pickedObjectSavedColor = 0;
  }
  pick(cssPosition, scene, camera, time) {
+    const {pickingTexture, pixelBuffer} = this;

    // restore the color if there is a picked object
    if (this.pickedObject) {
      this.pickedObject.material.emissive.setHex(this.pickedObjectSavedColor);
      this.pickedObject = undefined;
    }

+    // set the view offset to represent just a single pixel under the mouse
+    const pixelRatio = renderer.getPixelRatio();
+    camera.setViewOffset(
+        renderer.getContext().drawingBufferWidth,   // full width
+        renderer.getContext().drawingBufferHeight,  // full top
+        cssPosition.x * pixelRatio | 0,             // rect x
+        cssPosition.y * pixelRatio | 0,             // rect y
+        1,                                          // rect width
+        1,                                          // rect height
+    );
+    // render the scene
+    renderer.setRenderTarget(pickingTexture)
+    renderer.render(scene, camera);
+    renderer.setRenderTarget(null);
+
+    // clear the view offset so rendering returns to normal
+    camera.clearViewOffset();
+    //read the pixel
+    renderer.readRenderTargetPixels(
+        pickingTexture,
+        0,   // x
+        0,   // y
+        1,   // width
+        1,   // height
+        pixelBuffer);
+
+    const id =
+        (pixelBuffer[0] &lt;&lt; 16) |
+        (pixelBuffer[1] &lt;&lt;  8) |
+        (pixelBuffer[2]      );

-    // cast a ray through the frustum
-    this.raycaster.setFromCamera(normalizedPosition, camera);
-    // get the list of objects the ray intersected
-    const intersectedObjects = this.raycaster.intersectObjects(scene.children);
-    if (intersectedObjects.length) {
-      // pick the first object. It's the closest one
-      this.pickedObject = intersectedObjects[0].object;

+    const intersectedObject = idToObject[id];
+    if (intersectedObject) {
+      // pick the first object. It's the closest one
+      this.pickedObject = intersectedObject;
      // save its color
      this.pickedObjectSavedColor = this.pickedObject.material.emissive.getHex();
      // set its emissive color to flashing red/yellow
      this.pickedObject.material.emissive.setHex((time * 8) % 2 &gt; 1 ? 0xFFFF00 : 0xFF0000);
    }
  }
}
</pre>
<p>それならば、それを使えばいいだけです。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-const pickHelper = new PickHelper();
+const pickHelper = new GPUPickHelper();
</pre>
<p>これを指定し <code class="notranslate" translate="no">scene</code> の代わりに <code class="notranslate" translate="no">pickScene</code> を渡します。</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-  pickHelper.pick(pickPosition, scene, camera, time);
+  pickHelper.pick(pickPosition, pickScene, camera, time);
</pre>
<p>そして、透明な部分を選択するようにする必要があります。</p>
<p></p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-picking-gpu.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-picking-gpu.html" target="_blank">ここをクリックして別のウィンドウで開きます</a>
</div>

<p></p>
<p>ピッキングを実装する方法のアイデアをいくつか得られたと思います。
今後の記事ではマウスを使ってオブジェクトを操作する方法を取り上げるかもしれません。</p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/threejs/lessons/threejs-picking.html">English
    </option><option value="/threejs/lessons/fr/threejs-picking.html">Français
    </option><option value="/threejs/lessons/ja/threejs-picking.html" selected="">日本語
    </option><option value="/threejs/lessons/kr/threejs-picking.html">한국어
    </option><option value="/threejs/lessons/ru/threejs-picking.html">Русский
    </option><option value="/threejs/lessons/zh_cn/threejs-picking.html">中文
</option></select>


        <div id="toc">
          <ul>  <li>基本</li>
        <ul>
          <li><a href="/threejs/lessons/ja/threejs-fundamentals.html">基礎知識</a></li>
<li><a href="/threejs/lessons/ja/threejs-responsive.html">レスポンシブデザイン</a></li>
<li><a href="/threejs/lessons/ja/threejs-prerequisites.html">前提条件</a></li>
<li><a href="/threejs/lessons/ja/threejs-setup.html">セットアップ</a></li>
        </ul>
  <li>基礎</li>
        <ul>
          <li><a href="/threejs/lessons/ja/threejs-primitives.html">プリミティブ</a></li>
<li><a href="/threejs/lessons/ja/threejs-scenegraph.html">シーングラフ</a></li>
<li><a href="/threejs/lessons/ja/threejs-materials.html">マテリアル</a></li>
<li><a href="/threejs/lessons/ja/threejs-textures.html">テクスチャ</a></li>
<li><a href="/threejs/lessons/ja/threejs-lights.html">ライト</a></li>
<li><a href="/threejs/lessons/ja/threejs-cameras.html">カメラ</a></li>
<li><a href="/threejs/lessons/ja/threejs-shadows.html">シャドウ</a></li>
<li><a href="/threejs/lessons/ja/threejs-fog.html">フォグ</a></li>
<li><a href="/threejs/lessons/ja/threejs-rendertargets.html">レンダーターゲット</a></li>
<li><a href="/threejs/lessons/ja/threejs-custom-buffergeometry.html">カスタムバッファジオメトリ</a></li>
        </ul>
  <li>Tips</li>
        <ul>
          <li><a href="/threejs/lessons/ja/threejs-rendering-on-demand.html">要求されたレンダリング</a></li>
<li><a href="/threejs/lessons/ja/threejs-debugging-javascript.html">JavaScriptのデバッグ</a></li>
<li><a href="/threejs/lessons/ja/threejs-debugging-glsl.html">GLSLのデバッグ</a></li>
<li><a href="/threejs/lessons/ja/threejs-tips.html#screenshot">スクリーンショットを撮る</a></li>
<li><a href="/threejs/lessons/ja/threejs-tips.html#preservedrawingbuffer">キャンバスがクリアされるのを防ぐ</a></li>
<li><a href="/threejs/lessons/ja/threejs-tips.html#tabindex">キャンバスからキーボード入力を取得する</a></li>
<li><a href="/threejs/lessons/ja/threejs-tips.html#transparent-canvas">キャンバスを透明にする</a></li>
<li><a href="/threejs/lessons/ja/threejs-tips.html#html-background">HTMLの背景にthree.jsを使う</a></li>
        </ul>
  <li>最適化</li>
        <ul>
          <li><a href="/threejs/lessons/ja/threejs-optimize-lots-of-objects.html">多くのオブジェクトを最適化</a></li>
<li><a href="/threejs/lessons/ja/threejs-optimize-lots-of-objects-animated.html">アニメーションする多くのオブジェクトを最適化</a></li>
<li><a href="/threejs/lessons/ja/threejs-offscreencanvas.html">Web WorkerでOffscreenCanvasを使用する</a></li>
        </ul>
  <li>解決策</li>
        <ul>
          <li><a href="/threejs/lessons/ja/threejs-load-obj.html">OBJファイルの読み込み</a></li>
<li><a href="/threejs/lessons/ja/threejs-load-gltf.html">GLTFファイルの読み込み</a></li>
<li><a href="/threejs/lessons/ja/threejs-backgrounds.html">背景やスカイボックスを追加する</a></li>
<li><a href="/threejs/lessons/ja/threejs-transparency.html">透明なオブジェクトの描画方法</a></li>
<li><a href="/threejs/lessons/ja/threejs-multiple-scenes.html">複数キャンバスと複数シーン</a></li>
<li><a href="/threejs/lessons/ja/threejs-picking.html">マウスでオブジェクトをピッキング</a></li>
<li><a href="/threejs/lessons/ja/threejs-post-processing.html">ポストプロセス</a></li>
<li><a href="/threejs/lessons/ja/threejs-post-processing-3dlut.html">エフェクトにLUTファイルを適用する</a></li>
<li><a href="/threejs/lessons/ja/threejs-shadertoy.html">Shadertoyのシェーダーを使う</a></li>
<li><a href="/threejs/lessons/ja/threejs-align-html-elements-to-3d.html">HTML要素を3Dに揃える</a></li>
<li><a href="/threejs/lessons/ja/threejs-indexed-textures.html">圧縮テクスチャのピッキングとカラー</a></li>
<li><a href="/threejs/lessons/ja/threejs-canvas-textures.html">動的なテクスチャのキャンバスを使用する</a></li>
<li><a href="/threejs/lessons/ja/threejs-billboards.html">Billboards and Facades</a></li>
<li><a href="/threejs/lessons/ja/threejs-cleanup.html">Freeing Resources</a></li>
<li><a href="/threejs/lessons/ja/threejs-voxel-geometry.html">Making Voxel Geometry (Minecraft)</a></li>
<li><a href="/threejs/lessons/ja/threejs-game.html">Start making a Game.</a></li>
        </ul>
  <li>WebVR</li>
        <ul>
          <li><a href="/threejs/lessons/ja/threejs-webvr.html">VR - Basics</a></li>
<li><a href="/threejs/lessons/ja/threejs-webvr-look-to-select.html">VR - Look To Select</a></li>
<li><a href="/threejs/lessons/ja/threejs-webvr-point-to-select.html">VR - Point To Select</a></li>
        </ul>
  <li>参照</li>
        <ul>
          <li><a href="/threejs/lessons/ja/threejs-material-table.html">Material Table</a></li>
        </ul></ul>
<ul>
  <li><a href="https://github.com/gfxfundamentals/threejsfundamentals">github</a></li>
  <li><a href="https://threejs.org">three.js</a></li>
  <li><a href="https://threejs.org/docs/">three.jsドキュメント</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        
    <div>Issue/Bug? <a href="http://github.com/greggman/threefundamentals/issues">またはgithubでissueを作って下さい</a>.</div>
  

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'threejsfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'Three.jsでピッキング';
            var disqus_title = 'Three.jsでピッキング';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("threejsfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>

<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "threejsfundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/threejs/lessons/resources/prettify.js"></script>
<script src="/threejs/lessons/resources/lesson.js"></script>
<script>
(function() {
  if (window.location.hostname.indexOf("threejsfundamentals.org") < 0) {
      return;
  }

  function addScript(src, fn) {
    const script = document.createElement('script');
    const firstScript = document.getElementsByTagName('script')[0];
    script.async = true;
    script.defer = true;
    if (fn) {
      script.addEventListener('load', fn);
    }
    script.src = src;
    firstScript.parentNode.insertBefore(script, firstScript);
  }

  addScript('//cdn.webglstats.com/stat.js');
  addScript('https://www.googletagmanager.com/gtag/js?id=UA-120733518-1', () => {
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-120733518-1');
  });
}());
</script>






</body></html>