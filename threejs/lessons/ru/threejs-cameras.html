<!DOCTYPE html>
<!-- this file is auto-generated from threejs/lessons/ru/threejs-cameras.md. Do not edited directly -->
<!--
Copyright 2018, Google Inc.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of Google Inc. nor the names of their
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Как использовать камеру в Three.js" />
<meta name="keywords" content="webgl graphics three.js" />
<meta name="thumbnail" content="https://threejsfundamentals.org/threejs/lessons/screenshots/threejs-cameras_ru.jpg" />

<meta property="og:title" content="Three.js - Камера" />
<meta property="og:type" content="website" />
<meta property="og:image" content="https://threejsfundamentals.org/threejs/lessons/screenshots/threejs-cameras_ru.jpg" />
<meta property="og:description" content="Как использовать камеру в Three.js" />
<meta property="og:url" content="https://threejsfundamentals.org/threejs/lessons/ru/threejs-cameras.html" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site" content="@greggman" />
<meta name="twitter:creator" content="@greggman" />
<meta name="twitter:domain" content="threejsfundamentals.org" />
<meta name="twitter:title" content="Three.js - Камера" />
<meta name="twitter:url" content="https://threejsfundamentals.org/threejs/lessons/ru/threejs-cameras.html" />
<meta name="twitter:description" content="Как использовать камеру в Three.js" />
<meta name="twitter:image:src" content="https://threejsfundamentals.org/threejs/lessons/screenshots/threejs-cameras_ru.jpg" />

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://threejsfundamentals.org/#website",
      "url":"https://threejsfundamentals.org/",
      "name":"ThreejsFundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://threejsfundamentals.org/threejs/lessons/ru/threejs-cameras.html#primaryimage",
      "url":"https://threejsfundamentals.org/threejs/lessons/screenshots/threejs-cameras_ru.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://threejsfundamentals.org/threejs/lessons/ru/threejs-cameras.html#webpage",
      "url":"https://threejsfundamentals.org/threejs/lessons/ru/threejs-cameras.html",
      "inLanguage":"ru",
      "name":"Three.js - Камера",
      "keywords":"webgl graphics three.js programming",
      "isPartOf":{
        "@id":"https://threejsfundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://threejsfundamentals.org/threejs/lessons/ru/threejs-cameras.html#primaryimage"
      }
    }
  ]
}
</script>

<title>Three.js - Камера</title>
<link href="/threejs/lessons/resources/threejsfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/threejs/lessons/resources/threejsfundamentals-icon.png">
<link rel="icon" href="/threejs/lessons/resources/threejsfundamentals-icon.png">

<link rel="stylesheet" href="/threejs/lessons/lang.css" />
<link rel="stylesheet" href="/threejs/lessons/resources/lesson.css" />
</head>
<body>
<div class="threejs_navbar">
  <div>
    <select class="language">
    <option value="/threejs/lessons/threejs-cameras.html" >English</a>
    <option value="/threejs/lessons/fr/threejs-cameras.html" >Français</a>
    <option value="/threejs/lessons/ja/threejs-cameras.html" >日本語</a>
    <option value="/threejs/lessons/kr/threejs-cameras.html" >한국어</a>
    <option value="/threejs/lessons/ru/threejs-cameras.html" selected>Русский</a>
    <option value="/threejs/lessons/zh_cn/threejs-cameras.html" >中文</a>
</select>


    <a href="#toc">Оглавление</a>
  </div>
</div>
<div class="threejs_header">
  <h1><a href="/threejs/lessons/ru/">threejsfundamentals.org</a></h1>
<style>
#forkongithub a {
    background: #000;
    color: #fff;
    text-decoration: none;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 2rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 300px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(150px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a:hover {
    background: #c11;
    color: #fff;
}
#forkongithub a::before,#forkongithub a::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub a::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
@media (max-width: 900px) {
    #forkongithub a{
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub a{
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><a href="https://github.com/gfxfundamentals/threejsfundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>Three.js - Камера</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>Эта статья является частью серии статей о three.js. 
Первая была <a href="threejs-fundamentals.html">об основах</a>.
Если вы её еще не читали, советую вам сделать это.</p>
<p>Давайте поговорим о камерах в three.js. Мы рассмотрели некоторые из них в <a href="threejs-fundamentals.html">первой статье</a> 
, но мы расскажем здесь об этом более подробно.</p>
<p>Самая распространенная камера в Three.js и та, которую мы использовали до этого момента, - <code class="notranslate" translate="no">PerspectiveCamera</code>. 
Она дает трехмерный вид, где вещи на расстоянии кажутся меньше, чем вещи рядом.</p>
<p><code class="notranslate" translate="no">PerspectiveCamera</code> определяет <em>frustum</em>. <a href="https://ru.wikipedia.org/wiki/Усечённая_пирамида"><em>Frustum</em> - усеченная пирамида, твердое тело</a>. 
Под твердым телом я подразумеваю, например, куб, конус, сферу, 
цилиндр и усеченный конус - все названия различных видов твердых тел.</p>
<div class="spread">
  <div><div data-diagram="shapeCube"></div><div>cube</div></div>
  <div><div data-diagram="shapeCone"></div><div>cone</div></div>
  <div><div data-diagram="shapeSphere"></div><div>sphere</div></div>
  <div><div data-diagram="shapeCylinder"></div><div>cylinder</div></div>
  <div><div data-diagram="shapeFrustum"></div><div>frustum</div></div>
</div>

<p>Я только указываю на это, потому что я не знал это в течение многих лет. 
Если в какой-нибудь книге или на веб странице будет упоминание <em>frustum</em> я закатывал глаза. 
Понимание того, что это название сплошной формы, сделало эти описания внезапно более понятными &#128517;</p>
<p>A <code class="notranslate" translate="no">PerspectiveCamera</code>определяет свой frustum на основе 4 свойств. <code class="notranslate" translate="no">near</code> определяет, 
где начинается фронт усечения. <code class="notranslate" translate="no">far</code> определяет, где он заканчивается. <code class="notranslate" translate="no">fov</code>поле обзора 
определяет высоту передней и задней частей усеченного конуса, вычисляя правильную высоту, 
чтобы получить указанное поле обзора в <code class="notranslate" translate="no">near</code> единицах измерения от камеры. <code class="notranslate" translate="no">aspect</code> определяет, 
насколько широким передние и задняя часть усеченного есть. Ширина усеченного конуса - 
это просто высота, умноженная на aspect.</p>
<p><img src="../resources/frustum-3d.svg" width="500" class="threejs_center"/></p>
<p>Давайте используем сцену из <a href="threejs-lights.html">предыдущей статьи</a> которая имеет плоскость 
земли, сферу и куб, и сделаем так, чтобы мы могли регулировать настройки камеры</p>
<p>Для этого мы сделаем <code class="notranslate" translate="no">MinMaxGUIHelper</code> для параметров <code class="notranslate" translate="no">near</code> и <code class="notranslate" translate="no">far</code>, так чтобы <code class="notranslate" translate="no">far</code> 
всегда был больше, чем <code class="notranslate" translate="no">near</code>. У него будут свойства <code class="notranslate" translate="no">min</code> и <code class="notranslate" translate="no">max</code>, которые dat.GUI будет 
настраивать. После настройки они установят 2 свойства, которые мы указываем.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">class MinMaxGUIHelper {
  constructor(obj, minProp, maxProp, minDif) {
    this.obj = obj;
    this.minProp = minProp;
    this.maxProp = maxProp;
    this.minDif = minDif;
  }
  get min() {
    return this.obj[this.minProp];
  }
  set min(v) {
    this.obj[this.minProp] = v;
    this.obj[this.maxProp] = Math.max(this.obj[this.maxProp], v + this.minDif);
  }
  get max() {
    return this.obj[this.maxProp];
  }
  set max(v) {
    this.obj[this.maxProp] = v;
    this.min = this.min;  // это вызовет setter min 
  }
}
</code></pre>
<p>Теперь мы можем настроить наш графический интерфейс следующим образом</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function updateCamera() {
  camera.updateProjectionMatrix();
}

const gui = new GUI();
gui.add(camera, &#39;fov&#39;, 1, 180).onChange(updateCamera);
const minMaxGUIHelper = new MinMaxGUIHelper(camera, &#39;near&#39;, &#39;far&#39;, 0.1);
gui.add(minMaxGUIHelper, &#39;min&#39;, 0.1, 50, 0.1).name(&#39;near&#39;).onChange(updateCamera);
gui.add(minMaxGUIHelper, &#39;max&#39;, 0.1, 50, 0.1).name(&#39;far&#39;).onChange(updateCamera);
</code></pre>
<p>Каждый раз, когда меняются настройки камеры, нам нужно вызывать функцию камеры 
<a href="PerspectiveCamera.updateProjectionMatrix"><code class="notranslate" translate="no">updateProjectionMatrix</code></a> поэтому мы сделали 
функцию <code class="notranslate" translate="no">updateCamera</code> передав ее в dat.GUI, чтобы вызывать ее, когда что-то меняется.</p>
<p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-cameras-perspective.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-cameras-perspective.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Вы можете просто значения и посмотреть, как они работают. Обратите внимание, что мы не делали 
<code class="notranslate" translate="no">aspect</code> сеттер, так как aspect взят из размера окна, поэтому, если вы хотите настроить aspect, 
откройте пример в новом окне, а затем измените размер окна.</p>
<p>Тем не менее, я думаю, что это немного трудно увидеть, поэтому давайте изменим пример, чтобы он имел 2 камеры. 
Один покажет нашу сцену, как мы видим ее выше, другой покажет другую камеру, смотрящую на сцену, 
которую рисует первая камера, и показывает frustum камеры.</p>
<p>Для этого мы можем использовать функцию ножниц (scissor) Three.js. Давайте изменим это, чтобы 
нарисовать 2 сцены с 2 камерами рядом, используя функцию scissor</p>
<p>Для начала давайте используем HTML и CSS, чтобы определить 2 элемента рядом друг с другом. 
Это также поможет нам с событиями, так что обе камеры могут иметь свои собственные <code class="notranslate" translate="no">OrbitControls</code>.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-html">&lt;body&gt;
  &lt;canvas id=&quot;c&quot;&gt;&lt;/canvas&gt;
+  &lt;div class=&quot;split&quot;&gt;
+     &lt;div id=&quot;view1&quot; tabindex=&quot;1&quot;&gt;&lt;/div&gt;
+     &lt;div id=&quot;view2&quot; tabindex=&quot;2&quot;&gt;&lt;/div&gt;
+  &lt;/div&gt;
&lt;/body&gt;
</code></pre>
<p>Для начала давайте используем HTML и CSS, чтобы расположить 2 элемента рядом друг с другом. 
Это также поможет нам с событиями, так что обе камеры могут иметь свои собственные</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-css">.split {
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  display: flex;
}
.split&gt;div {
  width: 100%;
  height: 100%;
}
</code></pre>
<p>Затем в нашем коде мы добавим <code class="notranslate" translate="no">CameraHelper</code>. <code class="notranslate" translate="no">CameraHelper</code> рисует frustum для <code class="notranslate" translate="no">Camera</code></p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const cameraHelper = new THREE.CameraHelper(camera);

...

scene.add(cameraHelper);
</code></pre>
<p>Теперь давайте посмотрим на 2 элемента view.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const view1Elem = document.querySelector(&#39;#view1&#39;); 
const view2Elem = document.querySelector(&#39;#view2&#39;);
</code></pre>
<p>И мы установим нашу существующую <code class="notranslate" translate="no">OrbitControls</code> так, чтобы она отвечала 
только за первый элемент представления.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-const controls = new OrbitControls(camera, canvas);
+const controls = new OrbitControls(camera, view1Elem);
</code></pre>
<p>Создадим вторую <code class="notranslate" translate="no">PerspectiveCamera</code> и вторую <code class="notranslate" translate="no">OrbitControls</code>.
Вторая <code class="notranslate" translate="no">OrbitControls</code> привязана ко второй камере и получает 
ввод от второго элемента view.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const camera2 = new THREE.PerspectiveCamera(
  60,  // fov
  2,   // aspect
  0.1, // near
  500, // far
);
camera2.position.set(40, 10, 30);
camera2.lookAt(0, 5, 0);

const controls2 = new OrbitControls(camera2, view2Elem);
controls2.target.set(0, 5, 0);
controls2.update();
</code></pre>
<p>Наконец, нам нужно визуализировать сцену с точки зрения каждой камеры, используя 
функцию ножниц (scissor), чтобы визуализировать только часть холста.</p>
<p>Вот функция, которая для данного элемента будет вычислять прямоугольник этого 
элемента, который перекрывает холст. Затем он установит плоскость отсечения (scissor) и область 
просмотра (fov) в этот прямоугольник и вернет aspect для этого размера.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function setScissorForElement(elem) {
  const canvasRect = canvas.getBoundingClientRect();
  const elemRect = elem.getBoundingClientRect();

  // вычисляем относительный прямоугольник холста
  const right = Math.min(elemRect.right, canvasRect.right) - canvasRect.left;
  const left = Math.max(0, elemRect.left - canvasRect.left);
  const bottom = Math.min(elemRect.bottom, canvasRect.bottom) - canvasRect.top;
  const top = Math.max(0, elemRect.top - canvasRect.top);

  const width = Math.min(canvasRect.width, right - left);
  const height = Math.min(canvasRect.height, bottom - top);

  //  установка области отсечения для рендеринга только на эту часть холста
  renderer.setScissor(left, top, width, height);
  renderer.setViewport(left, top, width, height);

  // return aspect
  return width / height;
}
</code></pre>
<p>И теперь мы можем использовать эту функцию, чтобы нарисовать сцену дважды в нашей функции <code class="notranslate" translate="no">render</code></p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">  function render() {

-    if (resizeRendererToDisplaySize(renderer)) {
-      const canvas = renderer.domElement;
-      camera.aspect = canvas.clientWidth / canvas.clientHeight;
-      camera.updateProjectionMatrix();
-    }

+    resizeRendererToDisplaySize(renderer);
+
+    // включить область отсечения
+    renderer.setScissorTest(true);
+
+    // render the original view
+    {
+      const aspect = setScissorForElement(view1Elem);
+
+      // настроить камеру для этого соотношения сторон
+      camera.aspect = aspect;
+      camera.updateProjectionMatrix();
+      cameraHelper.update();
+
+      // не рисуем Helper камеры в исходном представлении
+      cameraHelper.visible = false;
+
+      scene.background.set(0x000000);
+
+      // отрисовка
+      renderer.render(scene, camera);
+    }
+
+    // отрисовка со 2-й камеры
+    {
+      const aspect = setScissorForElement(view2Elem);
+
+      // настроить камеру для этого соотношения сторон
+      camera2.aspect = aspect;
+      camera2.updateProjectionMatrix();
+
+      // рисуем Helper камеры во втором представлении
+      cameraHelper.visible = true;
+
+      scene.background.set(0x000040);
+
+      renderer.render(scene, camera2);
+    }

-    renderer.render(scene, camera);

    requestAnimationFrame(render);
  }

  requestAnimationFrame(render);
}
</code></pre>
<p>Приведенный выше код устанавливает цвет фона сцены при рендеринге 
второго представления темно-синим, чтобы было проще различать два представления.</p>
<p>Мы также можем удалить наш <code class="notranslate" translate="no">updateCamera</code> код, так как мы обновляем все в функции <code class="notranslate" translate="no">render</code>.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-function updateCamera() {
-  camera.updateProjectionMatrix();
-}

const gui = new GUI();
-gui.add(camera, &#39;fov&#39;, 1, 180).onChange(updateCamera);
+gui.add(camera, &#39;fov&#39;, 1, 180);
const minMaxGUIHelper = new MinMaxGUIHelper(camera, &#39;near&#39;, &#39;far&#39;, 0.1);
-gui.add(minMaxGUIHelper, &#39;min&#39;, 0.1, 50, 0.1).name(&#39;near&#39;).onChange(updateCamera);
-gui.add(minMaxGUIHelper, &#39;max&#39;, 0.1, 50, 0.1).name(&#39;far&#39;).onChange(updateCamera);
+gui.add(minMaxGUIHelper, &#39;min&#39;, 0.1, 50, 0.1).name(&#39;near&#39;);
+gui.add(minMaxGUIHelper, &#39;max&#39;, 0.1, 50, 0.1).name(&#39;far&#39;);
</code></pre>
<p>И теперь вы можете использовать один вид, чтобы увидеть frustum другого.</p>
<p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-cameras-perspective-2-scenes.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-cameras-perspective-2-scenes.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Слева вы можете увидеть исходный вид, а справа вы можете увидеть вид, 
показывающий frustum камеры слева. Можно настроить 
<code class="notranslate" translate="no">near</code>, <code class="notranslate" translate="no">far</code>, <code class="notranslate" translate="no">fov</code> и перемещать камеру с помощью мыши. Вы можете увидеть, 
как то, что внутри frustum, показаное справа, появляется на сцене слева.</p>
<p>Отрегулируйте <code class="notranslate" translate="no">near</code> примерно до 20, и вы легко увидите, как передние 
объекты исчезают, поскольку их больше нет в усеченном конусе. 
Отрегулируйте <code class="notranslate" translate="no">far</code> ниже примерно 35, и вы начнете видеть, 
что наземная плоскость исчезает, поскольку она больше не находится 
в не усеченной области.</p>
<p>Возникает вопрос, почему бы просто не установить <code class="notranslate" translate="no">near</code> значение 0,0000000001 и <code class="notranslate" translate="no">far</code>
10000000000000 или что-то в этом роде, чтобы вы могли видеть все? Причина в том, что 
ваш GPU имеет столько точности, чтобы решить, находится ли что-то впереди или 
позади чего-то другого. Эта точность распределена между
<code class="notranslate" translate="no">near</code> и <code class="notranslate" translate="no">far</code>. Хуже того, по умолчанию точность закрытия камеры детализирована (резкое отсечение), 
а точность далеко от камеры - конечна. <code class="notranslate" translate="no">near</code> медленно расширяется по мере приближения <code class="notranslate" translate="no">far</code>.</p>
<p>Начиная с верхнего примера, давайте изменим код, вставив 20 сфер в ряд.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">{
  const sphereRadius = 3;
  const sphereWidthDivisions = 32;
  const sphereHeightDivisions = 16;
  const sphereGeo = new THREE.SphereBufferGeometry(sphereRadius, sphereWidthDivisions, sphereHeightDivisions);
  const numSpheres = 20;
  for (let i = 0; i &lt; numSpheres; ++i) {
    const sphereMat = new THREE.MeshPhongMaterial();
    sphereMat.color.setHSL(i * .73, 1, 0.5);
    const mesh = new THREE.Mesh(sphereGeo, sphereMat);
    mesh.position.set(-sphereRadius - 1, sphereRadius + 2, i * sphereRadius * -2.2);
    scene.add(mesh);
  }
}
</code></pre>
<p>и давайте установим <code class="notranslate" translate="no">near</code> = 0.00001</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const fov = 45;
const aspect = 2;  // the canvas default
-const near = 0.1;
+const near = 0.00001;
const far = 100;
const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
</code></pre>
<p>Нам также нужно немного подправить код графического интерфейса, 
чтобы позволить 0.00001, если значение редактируется</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-gui.add(minMaxGUIHelper, &#39;min&#39;, 0.1, 50, 0.1).name(&#39;near&#39;).onChange(updateCamera);
+gui.add(minMaxGUIHelper, &#39;min&#39;, 0.00001, 50, 0.00001).name(&#39;near&#39;).onChange(updateCamera);
</code></pre>
<p>Как ты думаешь, что произойдет?</p>
<p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-cameras-z-fighting.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-cameras-z-fighting.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Это пример <em>z fighting</em> (<a href="https://en.wikipedia.org/wiki/Z-fighting">сшивание</a>), когда графический процессор на вашем компьютере не обладает 
достаточной точностью, чтобы определить, какие пиксели находятся спереди, а какие - сзади.</p>
<p>На тот случай, если проблема не отображается на вашей машине, вот что я вижу на своей машине</p>
<div class="threejs_center"><img src="../resources/images/z-fighting.png" style="width: 570px;"></div>

<p>Одно из решений состоит в том, чтобы указать использование three.js другому методу для вычисления того, 
какие пиксели находятся спереди, а какие - сзади. Мы можем сделать это, включив,
<code class="notranslate" translate="no">logarithmicDepthBuffer</code> когда мы создаем <code class="notranslate" translate="no">WebGLRenderer</code></p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-const renderer = new THREE.WebGLRenderer({canvas});
+const renderer = new THREE.WebGLRenderer({
+  canvas,
+  logarithmicDepthBuffer: true,
+});
</code></pre>
<p>и с этим это может работать</p>
<p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-cameras-logarithmic-depth-buffer.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-cameras-logarithmic-depth-buffer.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Если это не помогло решить проблему, вы столкнулись с одной из причин, по которой 
вы не всегда можете использовать это решение. Причина в том, что это поддерживают 
только определенные графические процессоры. По состоянию на сентябрь 2018 года 
практически ни одно мобильное устройство не поддерживает это решение, как это 
делают большинство настольных компьютеров.</p>
<p>Другая причина не выбирать это решение - оно может быть значительно медленнее, 
чем стандартное решение.</p>
<p>Даже при таком решении разрешение все еще ограничено. Сделайте <code class="notranslate" translate="no">near</code> еще меньше или 
<code class="notranslate" translate="no">far</code> больше, и вы в конечном итоге столкнетесь с теми же проблемами.</p>
<p>Это означает, что вы всегда должны прилагать усилия к тому, чтобы выбрать параметр <code class="notranslate" translate="no">near</code>
и <code class="notranslate" translate="no">far</code>, которые соответствуют вашему варианту использования. 
Установите <code class="notranslate" translate="no">near</code> как можно дальше от камеры, чтобы все не исчезло. 
Установите <code class="notranslate" translate="no">far</code> как можно ближе к камере, чтобы все не исчезло. Если вы пытаетесь 
нарисовать гигантскую сцену и показать крупным планом чье-то лицо, чтобы вы 
могли видеть их ресницы, в то время как на заднем плане вы можете видеть весь 
путь в горы на расстоянии 50 километров, тогда вам нужно будет найти другое 
креативные решения, которые, возможно, мы рассмотрим позже. На данный момент, 
просто знайте, что вы должны позаботиться о том, чтобы выбрать подходящие 
<code class="notranslate" translate="no">near</code> и <code class="notranslate" translate="no">far</code> для ваших нужд.</p>
<p>2-ая ​​самая распространенная камера - <code class="notranslate" translate="no">OrthographicCamera</code>. Вместо того, 
чтобы указать frustum он указывает прямоугольный паралелепипед (box) 
с параметрами <code class="notranslate" translate="no">left</code>, <code class="notranslate" translate="no">right</code>, <code class="notranslate" translate="no">top</code>, <code class="notranslate" translate="no">bottom</code>, <code class="notranslate" translate="no">near</code>, и <code class="notranslate" translate="no">far</code>. 
Поскольку он проецирует box, перспективы нет.</p>
<p>Давайте изменим приведенный выше пример 2 для использования <code class="notranslate" translate="no">OrthographicCamera</code> 
в первом представлении.</p>
<p>Сначала давайте настроим <code class="notranslate" translate="no">OrthographicCamera</code>.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const left = -1;
const right = 1;
const top = 1;
const bottom = -1;
const near = 5;
const far = 50;
const camera = new THREE.OrthographicCamera(left, right, top, bottom, near, far);
camera.zoom = 0.2;
</code></pre>
<p>Мы устанавливаем <code class="notranslate" translate="no">left</code> и <code class="notranslate" translate="no">bottom</code> = -1 и <code class="notranslate" translate="no">right</code> и <code class="notranslate" translate="no">top</code> = 1. Это сделало бы 
прямоугольник шириной 2 единицы и высотой 2 единицы, но мы собираемся отрегулировать <code class="notranslate" translate="no">left</code> и <code class="notranslate" translate="no">top</code> 
в соответствии со отношением сторон прямоугольника, к которому мы рисуем. 
Мы будем использовать свойство <code class="notranslate" translate="no">zoom</code>, чтобы упростить настройку количества единиц, отображаемых камерой.</p>
<p>Давайте добавим настройки GUI для <code class="notranslate" translate="no">zoom</code></p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const gui = new GUI();
+gui.add(camera, &#39;zoom&#39;, 0.01, 1, 0.01).listen();
</code></pre>
<p>Вызовем <code class="notranslate" translate="no">listen</code> говорящий dat.GUI следить за изменениями. 
Потому что <code class="notranslate" translate="no">OrbitControls</code> также может управлять масштабированием. 
Например, колесо прокрутки на мыши будет масштабироваться с помощью <code class="notranslate" translate="no">OrbitControls</code>.</p>
<p>Наконец, нам просто нужно изменить часть, которая отображает левую сторону, 
чтобы обновить <code class="notranslate" translate="no">OrthographicCamera</code>.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">{
  const aspect = setScissorForElement(view1Elem);

  // обновить камеру для этого соотношения сторон
-  camera.aspect = aspect;
+  camera.left   = -aspect;
+  camera.right  =  aspect;
  camera.updateProjectionMatrix();
  cameraHelper.update();

  // не рисуем Helper камеры в исходном view
  cameraHelper.visible = false;

  scene.background.set(0x000000);
  renderer.render(scene, camera);
}
</code></pre>
<p>и теперь вы можете увидеть <code class="notranslate" translate="no">OrthographicCamera</code> в работе.</p>
<p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-cameras-orthographic-2-scenes.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-cameras-orthographic-2-scenes.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p><code class="notranslate" translate="no">OrthographicCamera</code> чаще всего используется для рисования 2D-объектов. 
Вы решаете, сколько единиц вы хотите, чтобы камера показывала. Например, 
если вы хотите, чтобы один пиксель холста соответствовал одному элементу 
камеры, вы можете сделать что-то вроде:</p>
<p>Поместить начало координат в центр и иметь 1 пиксель = 1 единицу three.js что-то вроде:</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">camera.left = -canvas.width / 2;
camera.right = canvas.width / 2;
camera.top = canvas.heigth / 2;
camera.bottom = -canvas.height / 2;
camera.near = -1;
camera.far = 1;
camera.zoom = 1;
</code></pre>
<p>Или, если бы мы хотели, чтобы источник находился в верхнем левом углу, 
как 2D-холст, мы могли бы использовать это</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">camera.left = 0;
camera.right = canvas.width;
camera.top = 0;
camera.bottom = canvas.height;
camera.near = -1;
camera.far = 1;
camera.zoom = 1;
</code></pre>
<p>В этом случае верхний левый угол будет 0,0, как 2D холст</p>
<p>Давай попробуем! Сначала давайте настроим камеру</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const left = 0;
const right = 300;  // default canvas size
const top = 0;
const bottom = 150;  // default canvas size
const near = -1;
const far = 1;
const camera = new THREE.OrthographicCamera(left, right, top, bottom, near, far);
camera.zoom = 1;
</code></pre>
<p>Затем давайте загрузим 6 текстур и сделаем 6 плоскостей, по одной на каждую текстуру. 
Мы будем привязывать каждую плоскость к <code class="notranslate" translate="no">THREE.Object3D</code> чтобы было легче сместить плоскость, 
чтобы ее центр находился в ее верхнем левом углу.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const loader = new THREE.TextureLoader();
const textures = [
  loader.load(&#39;../resources/images/flower-1.jpg&#39;),
  loader.load(&#39;../resources/images/flower-2.jpg&#39;),
  loader.load(&#39;../resources/images/flower-3.jpg&#39;),
  loader.load(&#39;../resources/images/flower-4.jpg&#39;),
  loader.load(&#39;../resources/images/flower-5.jpg&#39;),
  loader.load(&#39;../resources/images/flower-6.jpg&#39;),
];
const planeSize = 256;
const planeGeo = new THREE.PlaneBufferGeometry(planeSize, planeSize);
const planes = textures.map((texture) =&gt; {
  const planePivot = new THREE.Object3D();
  scene.add(planePivot);
  texture.magFilter = THREE.NearestFilter;
  const planeMat = new THREE.MeshBasicMaterial({
    map: texture,
    side: THREE.DoubleSide,
  });
  const mesh = new THREE.Mesh(planeGeo, planeMat);
  planePivot.add(mesh);
  // move plane so top left corner is origin
  mesh.position.set(planeSize / 2, planeSize / 2, 0);
  return planePivot;
});
</code></pre>
<p>и нам нужно обновить камеру, если размер холста изменится.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function render() {

  if (resizeRendererToDisplaySize(renderer)) {
    camera.right = canvas.width;
    camera.bottom = canvas.height;
    camera.updateProjectionMatrix();
  }

  ...
</code></pre>
<p><code class="notranslate" translate="no">planes</code> - массив <code class="notranslate" translate="no">THREE.Mesh</code>, по одному для каждой плоскости. 
Давайте переместим их в зависимости от времени.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function render(time) {
  time *= 0.001;  // конвертировать в секунды; 

  ...

  const distAcross = Math.max(20, canvas.width - planeSize);
  const distDown = Math.max(20, canvas.height - planeSize);

  // total distance to move across and back
  const xRange = distAcross * 2;
  const yRange = distDown * 2;
  const speed = 180;

  planes.forEach((plane, ndx) =&gt; {
    // compute a unique time for each plane
    const t = time * speed + ndx * 300;

    // get a value between 0 and range
    const xt = t % xRange;
    const yt = t % yRange;

    // set our position going forward if 0 to half of range
    // and backward if half of range to range
    const x = xt &lt; distAcross ? xt : xRange - xt;
    const y = yt &lt; distDown   ? yt : yRange - yt;

    plane.position.set(x, y, 0);
  });

  renderer.render(scene, camera);
</code></pre>
<p>И вы можете видеть, как изображения отскакивают от пикселей идеально по краям холста, 
используя пиксельную математику, как 2D холст</p>
<p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-cameras-orthographic-canvas-top-left-origin.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-cameras-orthographic-canvas-top-left-origin.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Другое распространенное использование <code class="notranslate" translate="no">OrthographicCamera</code> для рисования - это отображение вверх, 
вниз, влево, вправо, спереди, сзади программ трехмерного моделирования или редактора игрового движка.</p>
<div class="threejs_center"><img src="../resources/images/quad-viewport.png" style="width: 574px;"></div>

<p>На скриншоте выше вы можете видеть 1 вид в перспективе и 3 вида в ортогональном виде.</p>
<p>Это основы камер. Мы рассмотрим несколько распространенных способов перемещения камер в других статьях. 
А пока давайте перейдем к <a href="threejs-shadows.html">теням</a>.</p>
<p><canvas id="c"></canvas></p>
<script type="module" src="../resources/threejs-cameras.js"></script>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/threejs/lessons/threejs-cameras.html" >English</a>
    <option value="/threejs/lessons/fr/threejs-cameras.html" >Français</a>
    <option value="/threejs/lessons/ja/threejs-cameras.html" >日本語</a>
    <option value="/threejs/lessons/kr/threejs-cameras.html" >한국어</a>
    <option value="/threejs/lessons/ru/threejs-cameras.html" selected>Русский</a>
    <option value="/threejs/lessons/zh_cn/threejs-cameras.html" >中文</a>
</select>


        <div id="toc">
          <ul>  <li>Введение</li>
        <ul>
          <li><a href="/threejs/lessons/ru/threejs-fundamentals.html">Базовые принципы</a></li>
<li><a href="/threejs/lessons/ru/threejs-responsive.html">Адаптивный дизайн</a></li>
<li><a href="/threejs/lessons/ru/threejs-prerequisites.html">Необходимые условия</a></li>
<li><a href="/threejs/lessons/ru/threejs-setup.html">Настройка</a></li>
        </ul>
  <li>Фунаментальные понятия</li>
        <ul>
          <li><a href="/threejs/lessons/ru/threejs-primitives.html">Примитивы</a></li>
<li><a href="/threejs/lessons/ru/threejs-scenegraph.html">Граф сцены</a></li>
<li><a href="/threejs/lessons/ru/threejs-materials.html">Материалы</a></li>
<li><a href="/threejs/lessons/ru/threejs-textures.html">Текстуры</a></li>
<li><a href="/threejs/lessons/ru/threejs-lights.html">Освещение</a></li>
<li><a href="/threejs/lessons/ru/threejs-cameras.html">Камера</a></li>
<li><a href="/threejs/lessons/ru/threejs-shadows.html">Тени</a></li>
<li><a href="/threejs/lessons/ru/threejs-fog.html">Туман</a></li>
<li><a href="/threejs/lessons/ru/threejs-rendertargets.html">Цели рендеринга</a></li>
<li><a href="/threejs/lessons/ru/threejs-custom-geometry.html">Пользовательская Geometry</a></li>
<li><a href="/threejs/lessons/ru/threejs-custom-buffergeometry.html">Пользовательская BufferGeometry</a></li>
        </ul>
  <li>Советы</li>
        <ul>
          <li><a href="/threejs/lessons/ru/threejs-rendering-on-demand.html">Рендеринг по требованию</a></li>
<li><a href="/threejs/lessons/ru/threejs-debugging-javascript.html">Отладка JavaScript</a></li>
<li><a href="/threejs/lessons/ru/threejs-debugging-glsl.html">Отладка GLSL</a></li>
<li><a href="/threejs/lessons/ru/threejs-tips.html#screenshot">Делаем скриншот холста</a></li>
<li><a href="/threejs/lessons/ru/threejs-tips.html#preservedrawingbuffer">Предотвращение очистки холста </a></li>
<li><a href="/threejs/lessons/ru/threejs-tips.html#tabindex">Ввод с клавиатуры</a></li>
<li><a href="/threejs/lessons/ru/threejs-tips.html#transparent-canvas">Делаем холст прозрачным </a></li>
<li><a href="/threejs/lessons/ru/threejs-tips.html#html-background">Создание анимированного фона в three.js </a></li>
        </ul>
  <li>Optimization</li>
        <ul>
          <li><a href="/threejs/lessons/ru/threejs-optimize-lots-of-objects.html">Оптимизация большого количества объектов</a></li>
<li><a href="/threejs/lessons/ru/threejs-optimize-lots-of-objects-animated.html">Optimizing Lots of Objects Animated</a></li>
<li><a href="/threejs/lessons/ru/threejs-offscreencanvas.html">Using OffscreenCanvas in a Web Worker</a></li>
        </ul>
  <li>Решения</li>
        <ul>
          <li><a href="/threejs/lessons/ru/threejs-load-obj.html">Load an .OBJ file</a></li>
<li><a href="/threejs/lessons/ru/threejs-load-gltf.html">Load a .GLTF file</a></li>
<li><a href="/threejs/lessons/ru/threejs-backgrounds.html">Add a Background or Skybox</a></li>
<li><a href="/threejs/lessons/ru/threejs-transparency.html">How to Draw Transparent Objects</a></li>
<li><a href="/threejs/lessons/ru/threejs-multiple-scenes.html">Несколько холстов, несколько сцен</a></li>
<li><a href="/threejs/lessons/ru/threejs-picking.html">Picking Objects with the mouse</a></li>
<li><a href="/threejs/lessons/ru/threejs-post-processing.html">Post Processing</a></li>
<li><a href="/threejs/lessons/ru/threejs-post-processing-3dlut.html">Applying a LUT File for effects</a></li>
<li><a href="/threejs/lessons/ru/threejs-shadertoy.html">Using Shadertoy shaders</a></li>
<li><a href="/threejs/lessons/ru/threejs-align-html-elements-to-3d.html">Aligning HTML Elements to 3D</a></li>
<li><a href="/threejs/lessons/ru/threejs-indexed-textures.html">Using Indexed Textures for Picking and Color</a></li>
<li><a href="/threejs/lessons/ru/threejs-canvas-textures.html">Using A Canvas for Dynamic Textures</a></li>
<li><a href="/threejs/lessons/ru/threejs-billboards.html">Billboards and Facades</a></li>
<li><a href="/threejs/lessons/ru/threejs-cleanup.html">Freeing Resources</a></li>
<li><a href="/threejs/lessons/ru/threejs-voxel-geometry.html">Making Voxel Geometry (Minecraft)</a></li>
<li><a href="/threejs/lessons/ru/threejs-game.html">Start making a Game.</a></li>
        </ul>
  <li>WebVR</li>
        <ul>
          <li><a href="/threejs/lessons/ru/threejs-webvr.html">VR - Basics</a></li>
<li><a href="/threejs/lessons/ru/threejs-webvr-look-to-select.html">VR - Look To Select</a></li>
<li><a href="/threejs/lessons/ru/threejs-webvr-point-to-select.html">VR - Point To Select</a></li>
        </ul>
  <li>Ссылки</li>
        <ul>
          <li><a href="/threejs/lessons/ru/threejs-material-table.html">Таблица материалов</a></li>
        </ul></ul>
<ul>
  <li><a href="https://github.com/gfxfundamentals/threejsfundamentals">github</a></li>
  <li><a href="https://threejs.org">three.js</a></li>
  <li><a href="https://threejs.org/docs/">three.js docs</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        <div>Вопросы? <a href="http://stackoverflow.com/questions/tagged/three.js">Спросите на stackoverflow</a>.</div>
        <div>Нашли ошибку? <a href="http://github.com/gfxfundamentals/threejsfundamentals/issues">Создайте issue на github</a>.</div>

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'threejsfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'Three.js - Камера';
            var disqus_title = 'Three.js - Камера';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("threejsfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/threejs/lessons/resources/prettify.js"></script>
<script src="/threejs/lessons/resources/lesson.js"></script>
<script>
(function() {
  if (window.location.hostname.indexOf("threejsfundamentals.org") < 0) {
      return;
  }

  function addScript(src, fn) {
    const script = document.createElement('script');
    const firstScript = document.getElementsByTagName('script')[0];
    script.async = true;
    script.defer = true;
    if (fn) {
      script.addEventListener('load', fn);
    }
    script.src = src;
    firstScript.parentNode.insertBefore(script, firstScript);
  }

  addScript('//cdn.webglstats.com/stat.js');
  addScript('https://www.googletagmanager.com/gtag/js?id=UA-120733518-1', () => {
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-120733518-1');
  });
}());
</script>


</html>



