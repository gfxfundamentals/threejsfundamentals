<!DOCTYPE html>
<!-- this file is auto-generated from threejs/lessons/ru/threejs-shadows.md. Do not edited directly -->
<!--
Copyright 2018, Google Inc.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of Google Inc. nor the names of their
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Тени в Three.js" />
<meta name="keywords" content="webgl graphics three.js" />
<meta name="thumbnail" content="https://threejsfundamentals.org/threejs/lessons/screenshots/threejs-shadows_ru.jpg" />

<meta property="og:title" content="Three.js Тени" />
<meta property="og:type" content="website" />
<meta property="og:image" content="https://threejsfundamentals.org/threejs/lessons/screenshots/threejs-shadows_ru.jpg" />
<meta property="og:description" content="Тени в Three.js" />
<meta property="og:url" content="https://threejsfundamentals.org/threejs/lessons/ru/threejs-shadows.html" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site" content="@greggman" />
<meta name="twitter:creator" content="@greggman" />
<meta name="twitter:domain" content="threejsfundamentals.org" />
<meta name="twitter:title" content="Three.js Тени" />
<meta name="twitter:url" content="https://threejsfundamentals.org/threejs/lessons/ru/threejs-shadows.html" />
<meta name="twitter:description" content="Тени в Three.js" />
<meta name="twitter:image:src" content="https://threejsfundamentals.org/threejs/lessons/screenshots/threejs-shadows_ru.jpg" />

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://threejsfundamentals.org/#website",
      "url":"https://threejsfundamentals.org/",
      "name":"ThreejsFundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://threejsfundamentals.org/threejs/lessons/ru/threejs-shadows.html#primaryimage",
      "url":"https://threejsfundamentals.org/threejs/lessons/screenshots/threejs-shadows_ru.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://threejsfundamentals.org/threejs/lessons/ru/threejs-shadows.html#webpage",
      "url":"https://threejsfundamentals.org/threejs/lessons/ru/threejs-shadows.html",
      "inLanguage":"ru",
      "name":"Three.js Тени",
      "keywords":"webgl graphics three.js programming",
      "isPartOf":{
        "@id":"https://threejsfundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://threejsfundamentals.org/threejs/lessons/ru/threejs-shadows.html#primaryimage"
      }
    }
  ]
}
</script>

<title>Three.js Тени</title>
<link href="/threejs/lessons/resources/threejsfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/threejs/lessons/resources/threejsfundamentals-icon.png">
<link rel="icon" href="/threejs/lessons/resources/threejsfundamentals-icon.png">

<link rel="stylesheet" href="/threejs/lessons/lang.css" />
<link rel="stylesheet" href="/threejs/lessons/resources/lesson.css" />
</head>
<body>
<div class="threejs_navbar">
  <div>
    <select class="language">
    <option value="/threejs/lessons/threejs-shadows.html" >English</a>
    <option value="/threejs/lessons/fr/threejs-shadows.html" >Français</a>
    <option value="/threejs/lessons/kr/threejs-shadows.html" >한국어</a>
    <option value="/threejs/lessons/ru/threejs-shadows.html" selected>Русский</a>
    <option value="/threejs/lessons/zh_cn/threejs-shadows.html" >中文</a>
</select>


    <a href="#toc">Оглавление</a>
  </div>
</div>
<div class="threejs_header">
  <h1><a href="/threejs/lessons/ru/">threejsfundamentals.org</a></h1>
<style>
#forkongithub a {
    background: #000;
    color: #fff;
    text-decoration: none;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 2rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 300px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(150px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a:hover {
    background: #c11;
    color: #fff;
}
#forkongithub a::before,#forkongithub a::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub a::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
@media (max-width: 900px) {
    #forkongithub a{
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub a{
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><a href="https://github.com/gfxfundamentals/threejsfundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>Three.js Тени</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>Эта статья является частью серии статей о three.js. Первая статья - <a href="threejs-fundamentals.html">основы Three.js</a>. 
Если вы еще не читали их, и вы новичок в three.js, возможно, вы захотите начать с них.
<a href="threejs-cameras.html">Предыдущая статья была о камерах</a> ,которые важно прочитать, прежде чем читать эту статью, а также
<a href="threejs-lights.html">статью, посвященную свету</a>.</p>
<p>Тени на компьютерах могут быть сложной темой. Существуют различные решения, и у всех есть свои компромиссы, включая решения, доступные в three.js.</p>
<p>Three.js по умолчанию использует <em>shadow maps</em>. Shadow map работает так: <em>для каждого источника света, отбрасывающего тени, все объекты, 
помеченные для отбрасывания теней, визуализируются с точки зрения источника света</em>. <strong>ПРОЧИТАЙТЕ ЭТО СНОВА!</strong> и это запомнится. </p>
<p>Другими словами, если у вас есть 20 объектов и 5 источников света, и все 20 объектов отбрасывают тени, 
а все 5 источников отбрасывают тени, то вся ваша сцена будет нарисована 6 раз.
Все 20 объектов будут нарисованы для источника света № 1, затем все 20 объектов будут нарисованы для источника света № 2, 
затем № 3 и т. д., И, наконец, фактическая сцена будет нарисована с использованием данных из первых 5 визуализаций. </p>
<p>Становится хуже, если у вас есть точечный источник света, отбрасывающий тени, сцена должна быть нарисована 6 раз только для этого света!</p>
<p> По этим причинам часто приходится искать другие решения, кроме множества источников света, генерирующих тени. Одно общее решение состоит в том, 
 чтобы иметь несколько источников света, но только один направленный источник света, генерирующий тени. </p>
<p>Еще одно решение заключается в использовании карт освещения и / или карт окклюзии(преграждений) окружающей среды 
для предварительного расчета эффектов освещения в автономном режиме. 
Это приводит к статическому освещению или подсказкам статического освещения, но, по крайней мере, это быстро. Мы рассмотрим оба из них в другой статье. </p>
<p>Другое решение заключается в использовании поддельных теней. Создайте плоскость, поместите текстуру в градациях серого в плоскость, 
которая приближается к тени, нарисуйте ее над землей под вашим объектом.</p>
<p>Например, давайте использовать эту текстуру в качестве поддельной тени</p>
<div class="threejs_center"><img src="../../resources/images/roundshadow.png"></div>

<p>Мы будем использовать часть кода из <a href="threejs-cameras.html">предыдущей статьи</a>.</p>
<p>Давайте установим цвет фона на белый. </p>
<pre class="prettyprint"><code class="lang-js">const scene = new THREE.Scene();
+scene.background = new THREE.Color(&#39;white&#39;);
</code></pre>
<p>Затем мы установим ту же самую шахматную доску, но на этот раз она использует <code>MeshBasicMaterial</code>, так как нам не нужно освещение для земли.</p>
<pre class="prettyprint"><code class="lang-js">+const loader = new THREE.TextureLoader();

{
  const planeSize = 40;

-  const loader = new THREE.TextureLoader();
  const texture = loader.load(&#39;resources/images/checker.png&#39;);
  texture.wrapS = THREE.RepeatWrapping;
  texture.wrapT = THREE.RepeatWrapping;
  texture.magFilter = THREE.NearestFilter;
  const repeats = planeSize / 2;
  texture.repeat.set(repeats, repeats);

  const planeGeo = new THREE.PlaneBufferGeometry(planeSize, planeSize);
  const planeMat = new THREE.MeshBasicMaterial({
    map: texture,
    side: THREE.DoubleSide,
  });
+  planeMat.color.setRGB(1.5, 1.5, 1.5);
  const mesh = new THREE.Mesh(planeGeo, planeMat);
  mesh.rotation.x = Math.PI * -.5;
  scene.add(mesh);
}
</code></pre>
<p>Обратите внимание, что мы устанавливаем цвет на <code>1,5, 1,5, 1,5</code>. Это умножит цвета текстуры шахматной доски на 1,5, 1,5, 1,5. 
Так как цвета текстуры 0x808080 и 0xC0C0C0, которые являются средне-серыми и светло-серыми, 
умножение их на 1,5 даст нам белую и светло-серую шахматную доску.</p>
<p> Давайте загрузим текстуру тени</p>
<pre class="prettyprint"><code class="lang-js">const shadowTexture = loader.load(&#39;resources/images/roundshadow.png&#39;);
</code></pre>
<p>и сделаем массив для запоминания каждой сферы и связанных объектов.</p>
<pre class="prettyprint"><code class="lang-js">const sphereShadowBases = [];
</code></pre>
<p>Тогда мы сделаем геометрию сферы</p>
<pre class="prettyprint"><code class="lang-js">const sphereRadius = 1;
const sphereWidthDivisions = 32;
const sphereHeightDivisions = 16;
const sphereGeo = new THREE.SphereBufferGeometry(sphereRadius, sphereWidthDivisions, sphereHeightDivisions);
</code></pre>
<p>И геометрия плоскости для поддельной тени</p>
<pre class="prettyprint"><code class="lang-js">const planeSize = 1;
const shadowGeo = new THREE.PlaneBufferGeometry(planeSize, planeSize);
</code></pre>
<p>Теперь мы сделаем кучу сфер. Для каждой сферы мы создадим <code>base</code> <code>THREE.Object3D</code> и сделаем сетку теневой плоскости и дочернюю сетку базовой сферы.
Таким образом, если мы переместим основание, то и сфера, и тень будут двигаться. Нам нужно поместить тень немного выше земли, чтобы предотвратить z-fighting.
Мы также устанавливаем значение <code>deepWrite</code> в <code>false</code>, чтобы тени не мешали друг другу. Мы рассмотрим оба эти вопроса в <a href="threejs-transparency.html">другой статье</a>.
Тень - это <code>MeshBasicMaterial</code>, потому что ей не нужно освещение. </p>
<p>Мы делаем каждую сферу разным оттенком, а затем сохраняем ее вне основы, сетки сфер, сетки теней и начальной y-позиции каждой сферы.</p>
<pre class="prettyprint"><code class="lang-js">const numSpheres = 15;
for (let i = 0; i &lt; numSpheres; ++i) {
  // make a base for the shadow and the sphere
  // so they move together.
  const base = new THREE.Object3D();
  scene.add(base);

  // add the shadow to the base
  // note: we make a new material for each sphere
  // so we can set that sphere&#39;s material transparency
  // separately.
  const shadowMat = new THREE.MeshBasicMaterial({
    map: shadowTexture,
    transparent: true,    // so we can see the ground
    depthWrite: false,    // so we don&#39;t have to sort
  });
  const shadowMesh = new THREE.Mesh(shadowGeo, shadowMat);
  shadowMesh.position.y = 0.001;  // so we&#39;re above the ground slightly
  shadowMesh.rotation.x = Math.PI * -.5;
  const shadowSize = sphereRadius * 4;
  shadowMesh.scale.set(shadowSize, shadowSize, shadowSize);
  base.add(shadowMesh);

  // add the sphere to the base
  const u = i / numSpheres;   // goes from 0 to 1 as we iterate the spheres.
  const sphereMat = new THREE.MeshPhongMaterial();
  sphereMat.color.setHSL(u, 1, .75);
  const sphereMesh = new THREE.Mesh(sphereGeo, sphereMat);
  sphereMesh.position.set(0, sphereRadius + 2, 0);
  base.add(sphereMesh);

  // remember all 3 plus the y position
  sphereShadowBases.push({base, sphereMesh, shadowMesh, y: sphereMesh.position.y});
}
</code></pre>
<p>Мы установили 2 источника света. Одним из них является <code>HemisphereLight</code> с интенсивностью, установленной на 2, чтобы действительно осветлить вещи.</p>
<pre class="prettyprint"><code class="lang-js">{
  const skyColor = 0xB1E1FF;  // light blue
  const groundColor = 0xB97A20;  // brownish orange
  const intensity = 2;
  const light = new THREE.HemisphereLight(skyColor, groundColor, intensity);
  scene.add(light);
}
</code></pre>
<p>Другой - <code>DirectionalLight</code>, поэтому сферы получают некоторое определение.</p>
<pre class="prettyprint"><code class="lang-js">{
  const color = 0xFFFFFF;
  const intensity = 1;
  const light = new THREE.DirectionalLight(color, intensity);
  light.position.set(0, 10, 5);
  light.target.position.set(-5, 0, 0);
  scene.add(light);
  scene.add(light.target);
}
</code></pre>
<p>Он будет отображаться как есть, но давайте оживим сферы. 
Для каждой сферы, тени, базового набора мы перемещаем базу в плоскости xz, мы перемещаем сферу вверх и вниз,
используя <code>Math.abs (Math.sin (time))</code>, который дает нам оживленную анимацию. 
И мы также устанавливаем непрозрачность теневого материала таким образом, чтобы, когда каждая сфера поднималась выше, ее тень исчезала.</p>
<pre class="prettyprint"><code class="lang-js">function render(time) {
  time *= 0.001;  // convert to seconds

  ...

  sphereShadowBases.forEach((sphereShadowBase, ndx) =&gt; {
    const {base, sphereMesh, shadowMesh, y} = sphereShadowBase;

    // u is a value that goes from 0 to 1 as we iterate the spheres
    const u = ndx / sphereShadowBases.length;

    // compute a position for the base. This will move
    // both the sphere and its shadow
    const speed = time * .2;
    const angle = speed + u * Math.PI * 2 * (ndx % 1 ? 1 : -1);
    const radius = Math.sin(speed - ndx) * 10;
    base.position.set(Math.cos(angle) * radius, 0, Math.sin(angle) * radius);

    // yOff is a value that goes from 0 to 1
    const yOff = Math.abs(Math.sin(time * 2 + ndx));
    // move the sphere up and down
    sphereMesh.position.y = y + THREE.MathUtils.lerp(-2, 2, yOff);
    // fade the shadow as the sphere goes up
    shadowMesh.material.opacity = THREE.MathUtils.lerp(1, .25, yOff);
  });

  ...
</code></pre>
<p>И вот 15 видов прыгающих шаров.</p>
<p><div class="threejs_example_container">
  <div><iframe class="threejs_example" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-shadows-fake.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-shadows-fake.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>В некоторых приложениях обычно используют круглую или овальную тень для всего, но, конечно, 
вы также можете использовать теневые текстуры различной формы. Вы также можете придать тени более жесткий край.
Хорошим примером использования этого типа тени является <a href="https://www.google.com/search?tbm=isch&amp;q=animal+crossing+pocket+camp+screenshots">Animal Crossing Pocket Camp</a>
де вы можете видеть, что у каждого персонажа есть простая круглая тень. Это эффективно и дешево. 
<a href="https://www.google.com/search?q=monument+valley+screenshots&amp;tbm=isch">Monument Valley</a>
 кажется, также использует этот вид тени для главного героя. </p>
<p>Итак, переходя к теневым картам, есть 3 источника света, которые могут отбрасывать тени. <code>DirectionalLight</code>, <code>PointLight</code> и <code>SpotLight</code>.</p>
<p>Давайте начнем с <code>DirectionalLight</code> c вспомогательного примера из <a href="threejs-lights.html">статьи о светах</a>.</p>
<p>Первое, что нам нужно сделать, это включить тени в рендерере.</p>
<pre class="prettyprint"><code class="lang-js">const renderer = new THREE.WebGLRenderer({canvas});
+renderer.shadowMap.enabled = true;
</code></pre>
<p>Тогда мы также должны сказать свету отбрасывать тень</p>
<pre class="prettyprint"><code class="lang-js">const light = new THREE.DirectionalLight(color, intensity);
+light.castShadow = true;
</code></pre>
<p>Нам также нужно перейти к каждой сетке в сцене и решить, должна ли она отбрасывать тени и / или получать тени.</p>
<p>Давайте сделаем так, чтобы плоскость (земля) получала только тени, так как нам все равно, что происходит под ней.</p>
<pre class="prettyprint"><code class="lang-js">const mesh = new THREE.Mesh(planeGeo, planeMat);
mesh.receiveShadow = true;
</code></pre>
<p>Для куба и сферы давайте получим и отбросим тени</p>
<pre class="prettyprint"><code class="lang-js">const mesh = new THREE.Mesh(cubeGeo, cubeMat);
mesh.castShadow = true;
mesh.receiveShadow = true;

...

const mesh = new THREE.Mesh(sphereGeo, sphereMat);
mesh.castShadow = true;
mesh.receiveShadow = true;
</code></pre>
<p>И тогда мы запустим это.</p>
<p><div class="threejs_example_container">
  <div><iframe class="threejs_example" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-shadows-directional-light.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-shadows-directional-light.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Что произошло? Почему части теней отсутствуют? </p>
<p>Причина в том, что карты теней создаются путем рендеринга сцены с точки зрения света. 
В этом случае в <code>DirectionalLight</code> есть камера, которая смотрит на свою цель.  Точно так же, как <a href="threejs-cameras.html">камера, которую мы ранее покрывали</a>,
камера тени определяет область, внутри которой рендерится тени. В приведенном выше примере эта область слишком мала.</p>
<p>Чтобы визуализировать эту область, мы можем получить теневую камеру и добавить <code>CameraHelper</code> к сцене.</p>
<pre class="prettyprint"><code class="lang-js">const cameraHelper = new THREE.CameraHelper(light.shadow.camera);
scene.add(cameraHelper);
</code></pre>
<p>И теперь вы можете видеть область, для которой отбрасываются и принимаются тени.</p>
<p><div class="threejs_example_container">
  <div><iframe class="threejs_example" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-shadows-directional-light-with-camera-helper.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-shadows-directional-light-with-camera-helper.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Отрегулируйте целевое значение x назад и вперед, и должно быть довольно ясно, что только то, что находится внутри блока камеры тени, находится там, где рисуются тени. </p>
<p>Мы можем отрегулировать размер этой коробки, отрегулировав камеру освещения.</p>
<p>Давайте добавим некоторые настройки графического интерфейса, чтобы отрегулировать тень камеры освещения. 
Поскольку <code>DirectionalLight</code> представляет свет, движущийся в параллельном направлении,
<code>DirectionalLight</code> использует <code>OrthographicCamera</code> для своей теневой камеры. Мы рассмотрели, как работает 
<code>OrthographicCamera</code> в <a href="threejs-cameras.html">предыдущей статье о камерах</a>.</p>
<p>Напомним, <code>OrthographicCamera</code> определяет свою рамку или вид усечения по своим свойствам <code>left</code>, <code>right</code>, <code>top</code>, <code>bottom</code>, <code>near</code>, <code>far</code> и <code>zoom</code>. </p>
<p>Снова давайте создадим вспомогательный класс для dat.GUI. Мы сделаем <code>DimensionGUIHelper</code>, 
который мы передадим объект и 2 свойства. Он представит одно свойство, которое dat.GUI 
может настроить, и в ответ установит два значения: положительное и отрицательное.
Мы можем использовать это, чтобы установить влево и вправо как ширину, а вверх и вниз как высоту.</p>
<pre class="prettyprint"><code class="lang-js">class DimensionGUIHelper {
  constructor(obj, minProp, maxProp) {
    this.obj = obj;
    this.minProp = minProp;
    this.maxProp = maxProp;
  }
  get value() {
    return this.obj[this.maxProp] * 2;
  }
  set value(v) {
    this.obj[this.maxProp] = v /  2;
    this.obj[this.minProp] = v / -2;
  }
}
</code></pre>
<p>Мы также будем использовать <code>MinMaxGUIHelper</code>, который мы создали в статье о камере, для настройки ближнего и дальнего.</p>
<pre class="prettyprint"><code class="lang-js">const gui = new GUI();
gui.addColor(new ColorGUIHelper(light, &#39;color&#39;), &#39;value&#39;).name(&#39;color&#39;);
gui.add(light, &#39;intensity&#39;, 0, 2, 0.01);
+{
+  const folder = gui.addFolder(&#39;Shadow Camera&#39;);
+  folder.open();
+  folder.add(new DimensionGUIHelper(light.shadow.camera, &#39;left&#39;, &#39;right&#39;), &#39;value&#39;, 1, 100)
+    .name(&#39;width&#39;)
+    .onChange(updateCamera);
+  folder.add(new DimensionGUIHelper(light.shadow.camera, &#39;bottom&#39;, &#39;top&#39;), &#39;value&#39;, 1, 100)
+    .name(&#39;height&#39;)
+    .onChange(updateCamera);
+  const minMaxGUIHelper = new MinMaxGUIHelper(light.shadow.camera, &#39;near&#39;, &#39;far&#39;, 0.1);
+  folder.add(minMaxGUIHelper, &#39;min&#39;, 0.1, 50, 0.1).name(&#39;near&#39;).onChange(updateCamera);
+  folder.add(minMaxGUIHelper, &#39;max&#39;, 0.1, 50, 0.1).name(&#39;far&#39;).onChange(updateCamera);
+  folder.add(light.shadow.camera, &#39;zoom&#39;, 0.01, 1.5, 0.01).onChange(updateCamera);
+}
</code></pre>
<p>Мы говорим GUI, чтобы мы вызывали нашу функцию <code>updateCamera</code> каждый раз, когда что-то меняется. 
Давайте напишем эту функцию для обновления источника света, помощника источника света, 
камеры тени источника света и помощника, отображающего камеру тени источника света.</p>
<pre class="prettyprint"><code class="lang-js">function updateCamera() {
  // update the light target&#39;s matrixWorld because it&#39;s needed by the helper
  light.target.updateMatrixWorld();
  helper.update();
  // update the light&#39;s shadow camera&#39;s projection matrix
  light.shadow.camera.updateProjectionMatrix();
  // and now update the camera helper we&#39;re using to show the light&#39;s shadow camera
  cameraHelper.update();
}
updateCamera();
</code></pre>
<p>И теперь, когда мы дали теневой камере световой интерфейс, мы можем играть со значениями.</p>
<p><div class="threejs_example_container">
  <div><iframe class="threejs_example" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-shadows-directional-light-with-camera-gui.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-shadows-directional-light-with-camera-gui.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Установите <code>ширину</code> и <code>высоту</code> около 30, и вы увидите, что тени правильные и области, которые должны находиться в тени для этой сцены, полностью покрыты. </p>
<p>Но это поднимает вопрос, почему бы просто не установить <code>ширину</code> и <code>высоту</code> для некоторых гигантских чисел, 
чтобы просто покрыть все? Установите <code>ширину</code> и <code>высоту</code> 100, и вы можете увидеть что-то вроде этого</p>
<div class="threejs_center"><img src="../resources/images/low-res-shadow-map.png" style="width: 369px"></div>

<p>Что происходит с этими тенями в низком разрешении ?!</p>
<p>Эта проблема - еще один параметр, связанный с тенями, о котором нужно знать. Карты теней - это текстуры, в которые затягиваются тени.
Эти текстуры имеют размер. Область теневой камеры, которую мы установили выше, 
растянута на этот размер. Это означает, что чем больше область, которую вы устанавливаете, тем более блочными будут ваши тени.</p>
<p> Вы можете установить разрешение текстуры карты теней, установив <code>light.shadow.mapSize.width</code> и <code>light.shadow.mapSize.height</code>.
 Они по умолчанию 512x512. Чем больше вы делаете их, тем больше памяти они отнимают 
 и тем медленнее они вычисляются, поэтому вы захотите установить их как можно меньше и при этом заставить вашу сцену работать. 
 То же самое относится и к области камеры теневого света. Меньшие тени означают - лучше выглядящие, 
 поэтому сделайте область как можно меньше и при этом охватывайте всю сцену. Имейте в виду, что на компьютере каждого пользователя установлен максимально допустимый
 размер текстуры, который доступен в рендере как <a href="WebGLRenderer.capabilities"><code>renderer.capabilities.maxTextureSize</code></a>.</p>
<!--
Ok but what about `near` and `far` I hear you thinking. Can we set `near` to 0.00001 and far to `100000000`
-->
<p>При переключении на <code>SpotLight</code> теневая камера источника света становится <code>PerspectiveCamera</code>. 
В отличие от теневой камеры <code>DirectionalLight</code>, где мы могли вручную установить большинство ее настроек, 
теневая камера SpotLight управляется самим <code>SpotLight</code>. Поле зрения для теневой камеры напрямую связано с настройкой угла <code>SpotLight</code>. 
<code>aspect</code> устанавливается автоматически в зависимости от размера карты теней.</p>
<pre class="prettyprint"><code class="lang-js">-const light = new THREE.DirectionalLight(color, intensity);
+const light = new THREE.SpotLight(color, intensity);
</code></pre>
<p>и мы добавили обратно в настройку <code>полутени</code> и <code>угол</code> из нашей <a href="threejs-lights.html">статьи о светах</a>.</p>
<p><div class="threejs_example_container">
  <div><iframe class="threejs_example" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-shadows-spot-light-with-camera-gui.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-shadows-spot-light-with-camera-gui.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<!--
You can notice, just like the last example if we set the angle high
then the shadow map, the texture is spread over a very large area and
the resolution of our shadows gets really low.

div class="threejs_center"><img src="../resources/images/low-res-shadow-map-spotlight.png" style="width: 344px"></div>

You can increase the size of the shadow map as mentioned above. You can
also blur the result

<div class="threejs_example_container">
  <div><iframe class="threejs_example" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-shadows-spot-light-with-shadow-radius"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-shadows-spot-light-with-shadow-radius" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>


-->
<p>И, наконец, есть тени с <code>PointLight</code>. Так как <code>PointLight</code> светит во всех направлениях, единственные релевантные настройки - ближние и дальние.
В противном случае тень <code>PointLight</code> фактически представляет собой 6 теней <code>SpotLight</code>, каждая из которых указывает на грань куба вокруг источника света. 
Это означает, что тени <code>PointLight</code> намного медленнее, поскольку вся сцена должна быть нарисована 6 раз, по одному для каждого направления. </p>
<p>Давайте поместим рамку вокруг нашей сцены, чтобы мы могли видеть тени на стенах и потолке.
Мы установим свойство стороны материала в <code>THREE.BackSide</code>, чтобы отображать внутреннюю часть поля вместо внешней. Как и пол, мы установим его только для получения теней. 
Также мы установим положение ящика так, чтобы его дно было немного ниже пола, чтобы пол и дно ящика не мешали друг другу.</p>
<pre class="prettyprint"><code class="lang-js">{
  const cubeSize = 30;
  const cubeGeo = new THREE.BoxBufferGeometry(cubeSize, cubeSize, cubeSize);
  const cubeMat = new THREE.MeshPhongMaterial({
    color: &#39;#CCC&#39;,
    side: THREE.BackSide,
  });
  const mesh = new THREE.Mesh(cubeGeo, cubeMat);
  mesh.receiveShadow = true;
  mesh.position.set(0, cubeSize / 2 - 0.1, 0);
  scene.add(mesh);
}
</code></pre>
<p>И, конечно же, нам нужно переключить свет на <code>PointLight</code>.</p>
<pre class="prettyprint"><code class="lang-js">-const light = new THREE.SpotLight(color, intensity);
+const light = new THREE.PointLight(color, intensity);

....

// so we can easily see where the point light is
+const helper = new THREE.PointLightHelper(light);
+scene.add(helper);
</code></pre>
<p><div class="threejs_example_container">
  <div><iframe class="threejs_example" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-shadows-point-light.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-shadows-point-light.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Используйте настройки GUI для перемещения света, и вы увидите, как тени падают на все стены. 
Вы также можете настроить ближние и дальние настройки и видеть, как и другие тени, 
когда объекты ближе -  они больше не получают тень, когда объекты дальше - они всегда находятся в тени.</p>
<!--
self shadow, shadow acne
-->

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/threejs/lessons/threejs-shadows.html" >English</a>
    <option value="/threejs/lessons/fr/threejs-shadows.html" >Français</a>
    <option value="/threejs/lessons/kr/threejs-shadows.html" >한국어</a>
    <option value="/threejs/lessons/ru/threejs-shadows.html" selected>Русский</a>
    <option value="/threejs/lessons/zh_cn/threejs-shadows.html" >中文</a>
</select>


        <div id="toc">
          <ul>  <li>Введение</li>
        <ul>
          <li><a href="/threejs/lessons/ru/threejs-fundamentals.html">Базовые принципы</a></li>
<li><a href="/threejs/lessons/ru/threejs-responsive.html">Адаптивный дизайн</a></li>
<li><a href="/threejs/lessons/ru/threejs-prerequisites.html">Необходимые условия</a></li>
<li><a href="/threejs/lessons/ru/threejs-setup.html">Настройка</a></li>
        </ul>
  <li>Фунаментальные понятия</li>
        <ul>
          <li><a href="/threejs/lessons/ru/threejs-primitives.html">Примитивы</a></li>
<li><a href="/threejs/lessons/ru/threejs-scenegraph.html">Граф сцены</a></li>
<li><a href="/threejs/lessons/ru/threejs-materials.html">Материалы</a></li>
<li><a href="/threejs/lessons/ru/threejs-textures.html">Текстуры</a></li>
<li><a href="/threejs/lessons/ru/threejs-lights.html">Освещение</a></li>
<li><a href="/threejs/lessons/ru/threejs-cameras.html">Камера</a></li>
<li><a href="/threejs/lessons/ru/threejs-shadows.html">Тени</a></li>
<li><a href="/threejs/lessons/ru/threejs-fog.html">Туман</a></li>
<li><a href="/threejs/lessons/ru/threejs-rendertargets.html">Цели рендеринга</a></li>
<li><a href="/threejs/lessons/ru/threejs-custom-geometry.html">Пользовательская Geometry</a></li>
<li><a href="/threejs/lessons/ru/threejs-custom-buffergeometry.html">Пользовательская BufferGeometry</a></li>
        </ul>
  <li>Советы</li>
        <ul>
          <li><a href="/threejs/lessons/ru/threejs-rendering-on-demand.html">Рендеринг по требованию</a></li>
<li><a href="/threejs/lessons/ru/threejs-debugging-javascript.html">Отладка JavaScript</a></li>
<li><a href="/threejs/lessons/ru/threejs-debugging-glsl.html">Отладка GLSL</a></li>
<li><a href="/threejs/lessons/ru/threejs-tips.html#screenshot">Taking a screenshot</a></li>
<li><a href="/threejs/lessons/ru/threejs-tips.html#preservedrawingbuffer">Prevent the Canvas Being Cleared</a></li>
<li><a href="/threejs/lessons/ru/threejs-tips.html#tabindex">Get Keyboard Input From a Canvas</a></li>
<li><a href="/threejs/lessons/ru/threejs-tips.html#transparent-canvas">Make the Canvas Transparent</a></li>
<li><a href="/threejs/lessons/ru/threejs-tips.html#html-background">Use three.js as Background in HTML</a></li>
        </ul>
  <li>Optimization</li>
        <ul>
          <li><a href="/threejs/lessons/ru/threejs-optimize-lots-of-objects.html">Optimizing Lots of Objects</a></li>
<li><a href="/threejs/lessons/ru/threejs-optimize-lots-of-objects-animated.html">Optimizing Lots of Objects Animated</a></li>
<li><a href="/threejs/lessons/ru/threejs-offscreencanvas.html">Using OffscreenCanvas in a Web Worker</a></li>
        </ul>
  <li>Решения</li>
        <ul>
          <li><a href="/threejs/lessons/ru/threejs-load-obj.html">Load an .OBJ file</a></li>
<li><a href="/threejs/lessons/ru/threejs-load-gltf.html">Load a .GLTF file</a></li>
<li><a href="/threejs/lessons/ru/threejs-backgrounds.html">Add a Background or Skybox</a></li>
<li><a href="/threejs/lessons/ru/threejs-transparency.html">How to Draw Transparent Objects</a></li>
<li><a href="/threejs/lessons/ru/threejs-multiple-scenes.html">Несколько холстов, несколько сцен</a></li>
<li><a href="/threejs/lessons/ru/threejs-picking.html">Picking Objects with the mouse</a></li>
<li><a href="/threejs/lessons/ru/threejs-post-processing.html">Post Processing</a></li>
<li><a href="/threejs/lessons/ru/threejs-post-processing-3dlut.html">Applying a LUT File for effects</a></li>
<li><a href="/threejs/lessons/ru/threejs-shadertoy.html">Using Shadertoy shaders</a></li>
<li><a href="/threejs/lessons/ru/threejs-align-html-elements-to-3d.html">Aligning HTML Elements to 3D</a></li>
<li><a href="/threejs/lessons/ru/threejs-indexed-textures.html">Using Indexed Textures for Picking and Color</a></li>
<li><a href="/threejs/lessons/ru/threejs-canvas-textures.html">Using A Canvas for Dynamic Textures</a></li>
<li><a href="/threejs/lessons/ru/threejs-billboards.html">Billboards and Facades</a></li>
<li><a href="/threejs/lessons/ru/threejs-cleanup.html">Freeing Resources</a></li>
<li><a href="/threejs/lessons/ru/threejs-voxel-geometry.html">Making Voxel Geometry (Minecraft)</a></li>
<li><a href="/threejs/lessons/ru/threejs-game.html">Start making a Game.</a></li>
        </ul>
  <li>WebVR</li>
        <ul>
          <li><a href="/threejs/lessons/ru/threejs-webvr.html">VR - Basics</a></li>
<li><a href="/threejs/lessons/ru/threejs-webvr-look-to-select.html">VR - Look To Select</a></li>
<li><a href="/threejs/lessons/ru/threejs-webvr-point-to-select.html">VR - Point To Select</a></li>
        </ul>
  <li>Ссылки</li>
        <ul>
          <li><a href="/threejs/lessons/ru/threejs-material-table.html">Таблица материалов</a></li>
        </ul></ul>
<ul>
  <li><a href="https://github.com/gfxfundamentals/threejsfundamentals">github</a></li>
  <li><a href="https://threejs.org">three.js</a></li>
  <li><a href="https://threejs.org/docs/">three.js docs</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        <div>Вопросы? <a href="http://stackoverflow.com/questions/tagged/three.js">Спросите на stackoverflow</a>.</div>
        <div>Нашли ошибку? <a href="http://github.com/gfxfundamentals/threejsfundamentals/issues">Создайте issue на github</a>.</div>

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'threejsfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'Three.js Тени';
            var disqus_title = 'Three.js Тени';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("threejsfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/threejs/lessons/resources/prettify.js"></script>
<script src="/threejs/lessons/resources/lesson.js"></script>
<script>
(function() {
  if (window.location.hostname.indexOf("threejsfundamentals.org") < 0) {
      return;
  }

  function addScript(src, fn) {
    const script = document.createElement('script');
    const firstScript = document.getElementsByTagName('script')[0];
    script.async = true;
    script.defer = true;
    if (fn) {
      script.addEventListener('load', fn);
    }
    script.src = src;
    firstScript.parentNode.insertBefore(script, firstScript);
  }

  addScript('//cdn.webglstats.com/stat.js');
  addScript('https://www.googletagmanager.com/gtag/js?id=UA-120733518-1', () => {
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-120733518-1');
  });
}());
</script>


</html>



