<!DOCTYPE html>
<!-- this file is auto-generated from threejs/lessons/kr/threejs-lights.md. Do not edited directly -->
<!--
Copyright 2018, Google Inc.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of Google Inc. nor the names of their
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ko">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="조명에 대해 알아봅니다" />
<meta name="keywords" content="webgl graphics three.js" />
<meta name="thumbnail" content="https://threejsfundamentals.org/threejs/lessons/screenshots/threejs-lights_ko.jpg" />

<meta property="og:title" content="Three.js의 조명" />
<meta property="og:type" content="website" />
<meta property="og:image" content="https://threejsfundamentals.org/threejs/lessons/screenshots/threejs-lights_ko.jpg" />
<meta property="og:description" content="조명에 대해 알아봅니다" />
<meta property="og:url" content="https://threejsfundamentals.org/threejs/lessons/kr/threejs-lights.html" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site" content="@greggman" />
<meta name="twitter:creator" content="@greggman" />
<meta name="twitter:domain" content="threejsfundamentals.org" />
<meta name="twitter:title" content="Three.js의 조명" />
<meta name="twitter:url" content="https://threejsfundamentals.org/threejs/lessons/kr/threejs-lights.html" />
<meta name="twitter:description" content="조명에 대해 알아봅니다" />
<meta name="twitter:image:src" content="https://threejsfundamentals.org/threejs/lessons/screenshots/threejs-lights_ko.jpg" />

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://threejsfundamentals.org/#website",
      "url":"https://threejsfundamentals.org/",
      "name":"ThreejsFundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://threejsfundamentals.org/threejs/lessons/kr/threejs-lights.html#primaryimage",
      "url":"https://threejsfundamentals.org/threejs/lessons/screenshots/threejs-lights_ko.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://threejsfundamentals.org/threejs/lessons/kr/threejs-lights.html#webpage",
      "url":"https://threejsfundamentals.org/threejs/lessons/kr/threejs-lights.html",
      "inLanguage":"ko",
      "name":"Three.js의 조명",
      "keywords":"webgl graphics three.js programming",
      "isPartOf":{
        "@id":"https://threejsfundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://threejsfundamentals.org/threejs/lessons/kr/threejs-lights.html#primaryimage"
      }
    }
  ]
}
</script>

<title>Three.js의 조명</title>
<link href="/threejs/lessons/resources/threejsfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/threejs/lessons/resources/threejsfundamentals-icon.png">
<link rel="icon" href="/threejs/lessons/resources/threejsfundamentals-icon.png">

<link rel="stylesheet" href="/threejs/lessons/lang.css" />
<link rel="stylesheet" href="/threejs/lessons/kr/lang.css" />
<link rel="stylesheet" href="/threejs/lessons/resources/lesson.css" />
</head>
<body>
<div class="threejs_navbar">
  <div>
    <select class="language">
    <option value="/threejs/lessons/threejs-lights.html" >English</a>
    <option value="/threejs/lessons/fr/threejs-lights.html" >Français</a>
    <option value="/threejs/lessons/ja/threejs-lights.html" >日本語</a>
    <option value="/threejs/lessons/kr/threejs-lights.html" selected>한국어</a>
    <option value="/threejs/lessons/ru/threejs-lights.html" >Русский</a>
    <option value="/threejs/lessons/zh_cn/threejs-lights.html" >中文</a>
</select>


    <a href="#toc">목차</a>
  </div>
</div>
<div class="threejs_header">
  <h1><a href="/threejs/lessons/kr/">threejsfundamentals.org</a></h1>
<style>
#forkongithub a {
    background: #000;
    color: #fff;
    text-decoration: none;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 2rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 300px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(150px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a:hover {
    background: #c11;
    color: #fff;
}
#forkongithub a::before,#forkongithub a::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub a::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
@media (max-width: 900px) {
    #forkongithub a{
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub a{
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><a href="https://github.com/gfxfundamentals/threejsfundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>Three.js의 조명</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>※ 이 글은 Three.js의 튜토리얼 시리즈로서,
먼저 <a href="threejs-fundamentals.html">Three.js의 기본 구조에 관한 글</a>과
<a href="threejs-setup.html">개발 환경 설정하는 법</a>을 읽고 오길 권장합니다.</p>
<p>이전 글은 <a href="threejs-textures.html">텍스처에 관한 글</a>이었죠. 이번에는
Three.js의 다양한 조명을 어떻게 쓰는지 알아보겠습니다.</p>
<p>먼저 이전 예제에서 카메라를 수정하겠습니다. 시야각(fov, field of view)은
45도, <code class="notranslate" translate="no">far</code>면은 100칸, 카메라의 위치는 중점에서 위로 10칸, 뒤로 20칸 옮깁니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">*const fov = 45;
const aspect = 2;  // canvas 요소의 기본 비율
const near = 0.1;
*const far = 100;
const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
+camera.position.set(0, 10, 20);
</code></pre>
<p>다음으로 <code class="notranslate" translate="no">OrbitControls</code>를 추가합니다. <code class="notranslate" translate="no">OrbitControls</code>는 특정 좌표를
중심으로 카메라를 자전 또는 <em>공전(orbit)</em>하도록 해줍니다. <code class="notranslate" translate="no">OrbitControls</code>는
별도 모듈이므로, 먼저 페이지에 로드해야 합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">import * as THREE from &#39;./resources/three/r119/build/three.module.js&#39;;
+import { OrbitControls } from &#39;./resources/threejs/r119/examples/jsm/controls/OrbitControls.js&#39;;
</code></pre>
<p>이제 <code class="notranslate" translate="no">OrbitControls</code>에 카메라와, DOM 이벤트를 감지할 수 있도록
canvas 요소를 넘겨줍니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const controls = new OrbitControls(camera, canvas);
controls.target.set(0, 5, 0);
controls.update();
</code></pre>
<p>또한 시점을 중점에서 위로 5칸 올린 후 <code class="notranslate" translate="no">controls.update</code> 메서드를
호출해 <code class="notranslate" translate="no">OrbitControls</code>가 새로운 시점을 바라보게 합니다.</p>
<p>다음으로 빛을 받을 무언가를 만들어보겠습니다. 먼저 땅의 역할을 할
평면을 만들고, 평면에 2x2 픽셀의 체크판 텍스처를 씌우겠습니다.</p>
<div class="threejs_center">
  <img src="../../resources/images/checker.png" class="border" style="
    image-rendering: pixelated;
    width: 128px;
  ">
</div>

<p>일단 텍스처를 불러온 뒤, 반복하도록 래핑(wrapping)을 설정해줍니다. 필터는
<code class="notranslate" translate="no">NearestFilter</code>, 텍스처가 2x2 픽셀의 체크판이니 <code class="notranslate" translate="no">repeat</code> 속성을 평면의
반으로 설정하면 체크판의 각 칸은 정확히 (장면의) 1칸이 될 겁니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const planeSize = 40;

const loader = new THREE.TextureLoader();
const texture = loader.load(&#39;resources/images/checker.png&#39;);
texture.wrapS = THREE.RepeatWrapping;
texture.wrapT = THREE.RepeatWrapping;
texture.magFilter = THREE.NearestFilter;
const repeats = planeSize / 2;
texture.repeat.set(repeats, repeats);
</code></pre>
<p>그리고 평면 <code class="notranslate" translate="no">geometry</code>, 평면에 쓸 재질(material), 장면(scene)에 추가할
<code class="notranslate" translate="no">mesh</code>를 만듭니다. 평면은 기본적으로 XY축을 기준으로 하니, XZ축을 기준으로
하려면 평면을 회전시켜야 합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const planeGeo = new THREE.PlaneBufferGeometry(planeSize, planeSize);
const planeMat = new THREE.MeshPhongMaterial({
  map: texture,
  side: THREE.DoubleSide,
});
const mesh = new THREE.Mesh(planeGeo, planeMat);
mesh.rotation.x = Math.PI * -.5;
scene.add(mesh);
</code></pre>
<p>정육면체와 구체도 추가해서 평면까지 총 3개의 물체를 추가하도록 하죠.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">{
  const cubeSize = 4;
  const cubeGeo = new THREE.BoxBufferGeometry(cubeSize, cubeSize, cubeSize);
  const cubeMat = new THREE.MeshPhongMaterial({color: &#39;#8AC&#39;});
  const mesh = new THREE.Mesh(cubeGeo, cubeMat);
  mesh.position.set(cubeSize + 1, cubeSize / 2, 0);
  scene.add(mesh);
}
{
  const sphereRadius = 3;
  const sphereWidthDivisions = 32;
  const sphereHeightDivisions = 16;
  const sphereGeo = new THREE.SphereBufferGeometry(sphereRadius, sphereWidthDivisions, sphereHeightDivisions);
  const sphereMat = new THREE.MeshPhongMaterial({color: &#39;#CA8&#39;});
  const mesh = new THREE.Mesh(sphereGeo, sphereMat);
  mesh.position.set(-sphereRadius - 1, sphereRadius + 2, 0);
  scene.add(mesh);
}
</code></pre>
<p>빛을 받을 물체를 만들었으니 이제 조명을 가지고 놀아봅시다!</p>
<h2 id="-ambientlight-"><code class="notranslate" translate="no">AmbientLight</code></h2>
<p>먼저 <code class="notranslate" translate="no">AmbientLight</code>(자연광)를 써보겠습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const color = 0xFFFFFF;
const intensity = 1;
const light = new THREE.AmbientLight(color, intensity);
scene.add(light);
</code></pre>
<p>이 조명도 <a href="https://github.com/dataarts/dat.gui">dat.GUI</a>를 사용해
속성을 조정할 수 있도록 만들겠습니다. dat.GUI로 색상을 조정하려면 간단한
헬퍼 클래스가 필요합니다. 이 클래스는 색상을 CSS hex(예: <code class="notranslate" translate="no">#FF8844</code>) 값으로
변경해 dat.GUI에 넘겨주는 역할을 할 거예요. 그리고 dat.GUI가 클래스의
속성을 지정할 때, 이를 조명에 직접 지정하도록 합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">class ColorGUIHelper {
  constructor(object, prop) {
    this.object = object;
    this.prop = prop;
  }
  get value() {
    return `#${this.object[this.prop].getHexString()}`;
  }
  set value(hexString) {
    this.object[this.prop].set(hexString);
  }
}
</code></pre>
<p>아래는 dat.GUI를 만드는 코드입니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const gui = new GUI();
gui.addColor(new ColorGUIHelper(light, &#39;color&#39;), &#39;value&#39;).name(&#39;color&#39;);
gui.add(light, &#39;intensity&#39;, 0, 2, 0.01);
</code></pre>
<p>결과물은 다음과 같죠.</p>
<p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-lights-ambient.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-lights-ambient.html" target="_blank">새 탭에서 보기</a>
</div>

</p>
<p>카메라를 <em>공전시키기(orbit)</em> 위해 화면을 드래그해보세요.</p>
<p>물체들이 평평하고, 윤곽이 뚜렷하지 않습니다. <code class="notranslate" translate="no">AmbientLight</code>는 물체와
조명의 색, 그리고 조명의 밝기를 곱한 것과 같죠.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">color = materialColor * light.color * light.intensity;
</code></pre><p>이게 전부입니다. <code class="notranslate" translate="no">AmbientLight</code>에는 방향이라는 개념이 없죠. 주변광은
완전히 고르게 적용되고 공간 안 물체의 색을 바꾸는 역할만 하기 때문에
실용적이지 않은데다 그다지 <em>조명</em>처럼 느껴지지도 않습니다. 어두운 장면을
덜 어둡게 만드는 정도에만 도움이 되죠.</p>
<h2 id="-hemispherelight-"><code class="notranslate" translate="no">HemisphereLight</code></h2>
<p>조명을 <code class="notranslate" translate="no">HemisphereLight</code>(반구광)으로 바꾸겠습니다. <code class="notranslate" translate="no">HemisphereLight</code>는
천장과 바닥의 색을 인자로 받아, 물체의 천장을 바라보는 면은 천장 색, 바닥을
바라보는 면은 바닥 색으로 혼합합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-const color = 0xFFFFFF;
+const skyColor = 0xB1E1FF;  // 하늘색
+const groundColor = 0xB97A20;  // 오렌지 브라운
const intensity = 1;
-const light = new THREE.AmbientLight(color, intensity);
+const light = new THREE.HemisphereLight(skyColor, groundColor, intensity);
scene.add(light);
</code></pre>
<p>마찬가지로 dat.GUI를 수정해 두 색상을 조정할 수 있도록 합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const gui = new GUI();
-gui.addColor(new ColorGUIHelper(light, &#39;color&#39;), &#39;value&#39;).name(&#39;color&#39;);
+gui.addColor(new ColorGUIHelper(light, &#39;color&#39;), &#39;value&#39;).name(&#39;skyColor&#39;);
+gui.addColor(new ColorGUIHelper(light, &#39;groundColor&#39;), &#39;value&#39;).name(&#39;groundColor&#39;);
gui.add(light, &#39;intensity&#39;, 0, 2, 0.01);
</code></pre>
<p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-lights-hemisphere.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-lights-hemisphere.html" target="_blank">새 탭에서 보기</a>
</div>

</p>
<p>이 또한 그다지 입체적이지 않습니다. 아까보다는 낮지만 전체적으로 2D처럼
보이네요. <code class="notranslate" translate="no">HemisphereLight</code>는 주로 풍경을 표현하거나 할 때 다른 조명과
함께 사용합니다. 다른 조명과 조합할 때 유용하고, 간단히는 <code class="notranslate" translate="no">AmbientLight</code>
대신 사용할 수 있죠.</p>
<h2 id="-directionallight-"><code class="notranslate" translate="no">DirectionalLight</code></h2>
<p>이번에는 조명을 <code class="notranslate" translate="no">DirectionalLight</code>(직사광)로 바꿔보죠. <code class="notranslate" translate="no">DirectionalLight</code>는
주로 태양을 표현할 때 사용합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const color = 0xFFFFFF;
const intensity = 1;
const light = new THREE.DirectionalLight(color, intensity);
light.position.set(0, 10, 0);
light.target.position.set(-5, 0, 0);
scene.add(light);
scene.add(light.target);
</code></pre>
<p>먼저 <code class="notranslate" translate="no">light</code>와 <code class="notranslate" translate="no">light.target</code>(목표)을 모두 장면에 추가해야 합니다.
그래야 Three.js의 <code class="notranslate" translate="no">DirectionalLight</code>가 목표가 있는 방향으로 빛을
쬘 테니까요.</p>
<p>이 역시 GUI를 사용해 목표의 위치를 조정할 수 있도록 만들겠습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const gui = new GUI();
gui.addColor(new ColorGUIHelper(light, &#39;color&#39;), &#39;value&#39;).name(&#39;color&#39;);
gui.add(light, &#39;intensity&#39;, 0, 2, 0.01);
gui.add(light.target.position, &#39;x&#39;, -10, 10);
gui.add(light.target.position, &#39;z&#39;, -10, 10);
gui.add(light.target.position, &#39;y&#39;, 0, 10);
</code></pre>
<p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-lights-directional.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-lights-directional.html" target="_blank">새 탭에서 보기</a>
</div>

</p>
<p>조명의 위치가 보이지 않으니 정확한 동작을 확인하기가 좀 어렵네요.
다행히 Three.js에는 눈에 보이지 않는 요소의 시각화를 도와주는
다양한 헬퍼 객체가 있습니다. 이 경우 <code class="notranslate" translate="no">DirectionalLightHelper</code>를
사용해 조명을 면으로, 조명의 방향을 선으로 나타낼 수 있습니다.
사용법도 간단해서 조명을 인자로 넘겨주고 생성한 인스턴스를 장면에
추가하면 됩니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const helper = new THREE.DirectionalLightHelper(light);
scene.add(helper);
</code></pre>
<p>하는 김에 조명과 목표 둘 다 위치를 조정할 수 있도록 하겠습니다.
<code class="notranslate" translate="no">Vector3</code> 객체를 인자로 받아, <code class="notranslate" translate="no">dat.GUI</code>로 이 객체의 <code class="notranslate" translate="no">x</code>, <code class="notranslate" translate="no">y</code>,
<code class="notranslate" translate="no">z</code> 속성을 조정하는 함수를 하나 만듭니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function makeXYZGUI(gui, vector3, name, onChangeFn) {
  const folder = gui.addFolder(name);
  folder.add(vector3, &#39;x&#39;, -10, 10).onChange(onChangeFn);
  folder.add(vector3, &#39;y&#39;, 0, 10).onChange(onChangeFn);
  folder.add(vector3, &#39;z&#39;, -10, 10).onChange(onChangeFn);
  folder.open();
}
</code></pre>
<p>헬퍼 객체를 사용할 때는 헬퍼 객체의 <code class="notranslate" translate="no">update</code> 메서드를 수동으로
호출해줘야 합니다. 한 예로 dat.GUI가 객체 속성을 변경할 때마다
인자로 넘겨준 <code class="notranslate" translate="no">onChangeFn</code>에서 헬퍼 객체의 <code class="notranslate" translate="no">update</code> 메서드를
호출할 수 있죠.</p>
<p>그리고 조명의 위치, 목표의 위치 객체에 방금 만든 함수를 각각 적용합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">+function updateLight{
+  light.target.updateMatrixWorld();
+  helper.update();
+}
+updateLight();

const gui = new GUI();
gui.addColor(new ColorGUIHelper(light, &#39;color&#39;), &#39;value&#39;).name(&#39;color&#39;);
gui.add(light, &#39;intensity&#39;, 0, 2, 0.01);

+makeXYZGUI(gui, light.position, &#39;position&#39;, updateLight);
+makeXYZGUI(gui, light.target.position, &#39;target&#39;, updateLight);
</code></pre>
<p>이제 조명, 목표의 위치를 각각 조정할 수 있습니다.</p>
<p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-lights-directional-w-helper.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-lights-directional-w-helper.html" target="_blank">새 탭에서 보기</a>
</div>

</p>
<p>카메라를 돌려보면 아까보다 훨씬 동작이 명확하게 보일 겁니다.
평면은 <code class="notranslate" translate="no">DirectionalLight</code>를 나타내는데, 이는 직사광이 어느
<em>한 점</em>에서 뻗어나오는 조명이 아니기 때문입니다. 무한한 광원이
목표를 향해 평행하게 빛을 내리쬐는 것이죠.</p>
<h2 id="-pointlight-"><code class="notranslate" translate="no">PointLight</code></h2>
<p><code class="notranslate" translate="no">PointLight</code>는 한 점에서 무한히 뻗어나가는 광원입니다. 코드를
다시 한 번 수정해보죠.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const color = 0xFFFFFF;
const intensity = 1;
-const light = new THREE.DirectionalLight(color, intensity);
+const light = new THREE.PointLight(color, intensity);
light.position.set(0, 10, 0);
-light.target.position.set(-5, 0, 0);
scene.add(light);
-scene.add(light.target);
</code></pre>
<p>헬퍼 객체도 <code class="notranslate" translate="no">PointLightHelper</code>로 바꾸겠습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-const helper = new THREE.DirectionalLightHelper(light);
+const helper = new THREE.PointLightHelper(light);
scene.add(helper);
</code></pre>
<p><code class="notranslate" translate="no">PointLight</code>에는 목표가 없으므로 <code class="notranslate" translate="no">onChange</code> 함수도 훨씬 간단하게
짤 수 있습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function updateLight{
-  light.target.updateMatrixWorld();
  helper.update();
}
-updateLight();
</code></pre>
<p><code class="notranslate" translate="no">PointLightHelper</code>는 점의 표상을 그립니다. 점의 표상이란 점으로는 확인이 어려우니,
기본값으로 다이아몬드 형태의 와이어프레임(wireframe)을 대신 그려놓은 것이죠. 점의
형태는 조명에 <code class="notranslate" translate="no">mesh</code> 객체를 하나 넘겨 얼마든지 바꿀 수 있습니다.</p>
<p><code class="notranslate" translate="no">PointLight</code>에는 추가로 <a href="PointLight.distance"><code class="notranslate" translate="no">distance</code></a> 속성이 있습니다.
<code class="notranslate" translate="no">distance</code>가이 0이면 <code class="notranslate" translate="no">PointLight</code>의 밝기가 무한대임을 의미하고,  0보다 크면
<code class="notranslate" translate="no">distance</code>에 지정된 거리만큼만 영향을 미칩니다.</p>
<p>거리도 조정할 수 있도록 GUI에 추가하겠습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const gui = new GUI();
gui.addColor(new ColorGUIHelper(light, &#39;color&#39;), &#39;value&#39;).name(&#39;color&#39;);
gui.add(light, &#39;intensity&#39;, 0, 2, 0.01);
+gui.add(light, &#39;distance&#39;, 0, 40).onChange(updateLight);

makeXYZGUI(gui, light.position, &#39;position&#39;, updateLight);
-makeXYZGUI(gui, light.target.position, &#39;target&#39;, updateLight);
</code></pre>
<p>이제 한 번 테스트해보죠.</p>
<p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-lights-point.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-lights-point.html" target="_blank">새 탭에서 보기</a>
</div>

</p>
<p><code class="notranslate" translate="no">distance</code>가 0보다 클 때 조명의 밝기를 잘 관찰해보세요.</p>
<h2 id="-spotlight-"><code class="notranslate" translate="no">SpotLight</code></h2>
<p>스포트라이트는 비유하자면 원뿔 안의 <code class="notranslate" translate="no">PointLight</code>입니다.
차이점은 원뿔 안에서만 빛난다는 점이죠. <code class="notranslate" translate="no">SpotLight</code>의
원뿔은 종류는 외부 원뿔과 내부 원뿔 두 가지입니다.
빛의 밝기는 내부 원뿔에서 가장 세고, 외부 원뿔에 가까워질수록
0까지 낮아집니다.</p>
<p><code class="notranslate" translate="no">DirectionalLight</code>와 마찬가지로 <code class="notranslate" translate="no">SpotLight</code>도 목표의 위치를
정해줘야 합니다. 원뿔의 밑면이 해당 목표물을 바라보게 되죠.</p>
<p>위 예제의 <code class="notranslate" translate="no">DirectionalLight</code>와 헬퍼 객체를 수정하겠습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const color = 0xFFFFFF;
const intensity = 1;
-const light = new THREE.DirectionalLight(color, intensity);
+const light = new THREE.SpotLight(color, intensity);
scene.add(light);
scene.add(light.target);

-const helper = new THREE.DirectionalLightHelper(light);
+const helper = new THREE.SpotLightHelper(light);
scene.add(helper);
</code></pre>
<p>원뿔의 내각은 <a href="SpotLight.angle"><code class="notranslate" translate="no">angle</code></a>에 호도(radians)값을 지정해
설정합니다. <a href="threejs-textures.html">텍스처 예제</a>에서 사용했던 <code class="notranslate" translate="no">DegRadHelper</code>
객체를 사용해 UI에는 도(degrees)로 표시하도록 하겠습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">gui.add(new DegRadHelper(light, &#39;angle&#39;), &#39;value&#39;, 0, 90).name(&#39;angle&#39;).onChange(updateLight);
</code></pre>
<p>내부 원뿔의 크기는 <a href="SpotLight.penumbra"><code class="notranslate" translate="no">penumbra(반음영)</code></a> 속성을 외부
원뿔에 대한 비율(퍼센트)로 지정해 사용합니다. 다시 말해 <code class="notranslate" translate="no">penumbra</code> 속성이
0이면 외부 원뿔과 크기가 동일하다는 것이고, 1이면 빛이 중앙에서부터 외부
원뿔까지 점점 희미해짐을 의미하죠. <code class="notranslate" translate="no">penumbra</code> 속성이 0.5이라면? 중앙과 외부
원뿔의 사이 50% 지점부터 빛이 희미해짐을 의미합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">gui.add(light, &#39;penumbra&#39;, 0, 1, 0.01);
</code></pre>
<p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-lights-spot-w-helper.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-lights-spot-w-helper.html" target="_blank">새 탭에서 보기</a>
</div>

</p>
<p><code class="notranslate" translate="no">penumbra</code> 속성이 0일 때는 빛의 경계가 굉장히 분명한 것이 보일 겁니다.
<code class="notranslate" translate="no">penumbra</code> 속성을 1에 가깝게 조정하면 경계가 점점 흐릿해지죠.</p>
<p><code class="notranslate" translate="no">SpotLight</code>가 <em>원뿔 모양</em>처럼 보이지 않을지도 모릅니다. 이는 바닥이 원뿔의
거리보다 가까이 있기 때문으로, <code class="notranslate" translate="no">distance</code>를 약 5 정도로 조정하면 원뿔의 밑면을
확인할 수 있을 겁니다.</p>
<h2 id="-rectarealight-"><code class="notranslate" translate="no">RectAreaLight</code></h2>
<p>마지막으로 살펴볼 조명은 <code class="notranslate" translate="no">RectAreaLight</code>입니다. 이름 그대로 사각 형태의
조명으로, 형광등이나 천장의 유리를 통과하는 태양빛을 표현하기에 적합합니다.</p>
<p><code class="notranslate" translate="no">RectAreaLight</code>는 <code class="notranslate" translate="no">MeshStandardMaterial</code>과 <code class="notranslate" translate="no">MeshPhysicalMaterial</code>만
지원합니다. 예전 코드에서 재질(material)을 <code class="notranslate" translate="no">MeshStandardMaterial</code>로 바꾸겠습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">  ...

  const planeGeo = new THREE.PlaneBufferGeometry(planeSize, planeSize);
-  const planeMat = new THREE.MeshPhongMaterial({
+  const planeMat = new THREE.MeshStandardMaterial({
    map: texture,
    side: THREE.DoubleSide,
  });
  const mesh = new THREE.Mesh(planeGeo, planeMat);
  mesh.rotation.x = Math.PI * -.5;
  scene.add(mesh);
}
{
  const cubeSize = 4;
  const cubeGeo = new THREE.BoxBufferGeometry(cubeSize, cubeSize, cubeSize);
- const cubeMat = new THREE.MeshPhongMaterial({color: &#39;#8AC&#39;});
+ const cubeMat = new THREE.MeshStandardMaterial({color: &#39;#8AC&#39;});
  const mesh = new THREE.Mesh(cubeGeo, cubeMat);
  mesh.position.set(cubeSize + 1, cubeSize / 2, 0);
  scene.add(mesh);
}
{
  const sphereRadius = 3;
  const sphereWidthDivisions = 32;
  const sphereHeightDivisions = 16;
  const sphereGeo = new THREE.SphereBufferGeometry(sphereRadius, sphereWidthDivisions, sphereHeightDivisions);
-  const sphereMat = new THREE.MeshPhongMaterial({color: &#39;#CA8&#39;});
+ const sphereMat = new THREE.MeshStandardMaterial({color: &#39;#CA8&#39;});
  const mesh = new THREE.Mesh(sphereGeo, sphereMat);
  mesh.position.set(-sphereRadius - 1, sphereRadius + 2, 0);
  scene.add(mesh);
}
</code></pre>
<p><code class="notranslate" translate="no">RectAreaLight</code>를 사용하려면 별도의 데이터를 불러와야 합니다. 또한
<code class="notranslate" translate="no">RectAreaLightHelper</code>도 같이 불러와 조명을 시각화하겠습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">import * as THREE from &#39;./resources/three/r119/build/three.module.js&#39;;
+import { RectAreaLightUniformsLib } from &#39;./resources/threejs/r119/examples/jsm/lights/RectAreaLightUniformsLib.js&#39;;
+import { RectAreaLightHelper } from &#39;./resources/threejs/r119/examples/jsm/helpers/RectAreaLightHelper.js&#39;;
</code></pre>
<p>모듈을 불러온 후 <code class="notranslate" translate="no">RectAreaLightUniformsLib.init</code> 메서드를 호출합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function main() {
  const canvas = document.querySelector(&#39;#c&#39;);
  const renderer = new THREE.WebGLRenderer({canvas});
+  RectAreaLightUniformsLib.init();
</code></pre>
<p>데이터를 불러오지 않아도 에러는 발생하지 않지만, 이상하게 보일 것이므로
데이터를 불러와야 한다는 것을 꼭 기억하기 바랍니다.</p>
<p>이제 조명을 추가합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const color = 0xFFFFFF;
*const intensity = 5;
+const width = 12;
+const height = 4;
*const light = new THREE.RectAreaLight(color, intensity, width, height);
light.position.set(0, 10, 0);
+light.rotation.x = THREE.MathUtils.degToRad(-90);
scene.add(light);

*const helper = new RectAreaLightHelper(light);
*light.add(helper);
</code></pre>
<p><code class="notranslate" translate="no">RectAreaLight</code>는 <code class="notranslate" translate="no">DirectionalLight</code>, <code class="notranslate" translate="no">SpotLight</code>와 달리 목표를 사용하지 않습니다.
빛의 방향은 <code class="notranslate" translate="no">rotation</code>으로 설정할 수 있죠. 또 <code class="notranslate" translate="no">RectAreaLightHelper</code>는 직접 조명을
자식으로 두는 다른 헬퍼 객체와 달리, 해당 조명의 자식이어야 합니다.</p>
<p>조명의 <code class="notranslate" translate="no">rotation</code>, <code class="notranslate" translate="no">width</code>, <code class="notranslate" translate="no">height</code> 속성을 조정할 수 있도록 GUI도 수정해줍니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const gui = new GUI();
gui.addColor(new ColorGUIHelper(light, &#39;color&#39;), &#39;value&#39;).name(&#39;color&#39;);
gui.add(light, &#39;intensity&#39;, 0, 10, 0.01);
gui.add(light, &#39;width&#39;, 0, 20).onChange(updateLight);
gui.add(light, &#39;height&#39;, 0, 20).onChange(updateLight);
gui.add(new DegRadHelper(light.rotation, &#39;x&#39;), &#39;value&#39;, -180, 180).name(&#39;x rotation&#39;).onChange(updateLight);
gui.add(new DegRadHelper(light.rotation, &#39;y&#39;), &#39;value&#39;, -180, 180).name(&#39;y rotation&#39;).onChange(updateLight);
gui.add(new DegRadHelper(light.rotation, &#39;z&#39;), &#39;value&#39;, -180, 180).name(&#39;z rotation&#39;).onChange(updateLight);

makeXYZGUI(gui, light.position, &#39;position&#39;, updateLight);
</code></pre>
<p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-lights-rectarea.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-lights-rectarea.html" target="_blank">새 탭에서 보기</a>
</div>

</p>
<p>하나 설명하지 않은 것이 있습니다. 위 예제에는 <code class="notranslate" translate="no">WebGLRenderer</code>의 <code class="notranslate" translate="no">physicallyCorrectLights(물리 기반 조명)</code>
설정이 있습니다. 이는 거리에 따라 빛이 어떻게 떨어질지 결정하는 속성으로,
<code class="notranslate" translate="no">PointLight</code>와 <code class="notranslate" translate="no">SpotLight</code>가 이 설정의 영향을 받습니다. <code class="notranslate" translate="no">RectAreaLight</code>는
마찬가지로 설정의 영향도 받고, 기본적으로 이 설정을 사용하죠.</p>
<p>이 설정을 사용하면 기본적으로 조명의 <code class="notranslate" translate="no">distance</code>나 <code class="notranslate" translate="no">intensity</code> 대신
<a href="PointLight.power"><code class="notranslate" translate="no">power</code></a> 속성을 루멘(lumens) 단위로 설정해야 합니다.
그러면 Three.js는 물리적 계산을 통해 실제 광원을 흉내내죠. 예제의
거리 단위는 미터(meters)이니, 60w짜리 전구는 약 800루멘 정도일 겁니다.
그리고 조명의 부서짐(decay) 정도를 설정하는 <a href="PointLight.decay"><code class="notranslate" translate="no">decay</code></a>
속성도 있습니다. 현실적인 조명을 위해서는 <code class="notranslate" translate="no">2</code> 정도가 적당하죠.</p>
<p>한 번 예제를 만들어 테스트해봅시다.</p>
<p>먼저 <code class="notranslate" translate="no">renderer</code>의 <code class="notranslate" translate="no">physicallyCorrectLights</code> 속성을 켭니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const renderer = new THREE.WebGLRenderer({canvas});
+renderer.physicallyCorrectLights = true;
</code></pre>
<p>그리고 <code class="notranslate" translate="no">power</code>를 800루멘으로, <code class="notranslate" translate="no">decay</code> 속성을 2로, <code class="notranslate" translate="no">distance</code>
속성을 <code class="notranslate" translate="no">Infinity</code>로 설정합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const color = 0xFFFFFF;
const intensity = 1;
const light = new THREE.PointLight(color, intensity);
light.power = 800;
light.decay = 2;
light.distance = Infinity;
</code></pre>
<p>마지막으로 GUI를 추가해 <code class="notranslate" translate="no">power</code>와 <code class="notranslate" translate="no">decay</code> 속성을 조정할 수 있도록
해줍니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const gui = new GUI();
gui.addColor(new ColorGUIHelper(light, &#39;color&#39;), &#39;value&#39;).name(&#39;color&#39;);
gui.add(light, &#39;decay&#39;, 0, 4, 0.01);
gui.add(light, &#39;power&#39;, 0, 2000);
</code></pre>
<p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-lights-point-physically-correct.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-lights-point-physically-correct.html" target="_blank">새 탭에서 보기</a>
</div>

</p>
<p>조명은 <code class="notranslate" translate="no">renderer</code>가 장면을 렌더링하는 속도에 영향을 미칩니다. 그러니
가능한 적은 조명을 쓰는 게 좋죠.</p>
<p>다음 장에서는 <a href="threejs-cameras.html">카메라 조작법</a>에 대해 알아보겠습니다.</p>
<p><canvas id="c"></canvas></p>
<script type="module" src="../resources/threejs-lights.js"></script>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/threejs/lessons/threejs-lights.html" >English</a>
    <option value="/threejs/lessons/fr/threejs-lights.html" >Français</a>
    <option value="/threejs/lessons/ja/threejs-lights.html" >日本語</a>
    <option value="/threejs/lessons/kr/threejs-lights.html" selected>한국어</a>
    <option value="/threejs/lessons/ru/threejs-lights.html" >Русский</a>
    <option value="/threejs/lessons/zh_cn/threejs-lights.html" >中文</a>
</select>


        <div id="toc">
          <ul>  <li>Three.js란?</li>
        <ul>
          <li><a href="/threejs/lessons/kr/threejs-fundamentals.html">Three.js란?</a></li>
<li><a href="/threejs/lessons/kr/threejs-responsive.html">반응형 디자인</a></li>
<li><a href="/threejs/lessons/kr/threejs-prerequisites.html">먼저 알아야 할 것들</a></li>
<li><a href="/threejs/lessons/kr/threejs-setup.html">개발 환경</a></li>
        </ul>
  <li>기본 구조</li>
        <ul>
          <li><a href="/threejs/lessons/kr/threejs-primitives.html">원시 모델</a></li>
<li><a href="/threejs/lessons/kr/threejs-scenegraph.html">씬 그래프</a></li>
<li><a href="/threejs/lessons/kr/threejs-materials.html">재질(Materials)</a></li>
<li><a href="/threejs/lessons/kr/threejs-textures.html">텍스처(Textures)</a></li>
<li><a href="/threejs/lessons/kr/threejs-lights.html">조명(Lights)</a></li>
<li><a href="/threejs/lessons/kr/threejs-cameras.html">카메라(Cameras)</a></li>
<li><a href="/threejs/lessons/kr/threejs-shadows.html">그림자(Shadows)</a></li>
<li><a href="/threejs/lessons/kr/threejs-fog.html">안개(Fog)</a></li>
<li><a href="/threejs/lessons/kr/threejs-rendertargets.html">렌더 타겟(Render Targets)</a></li>
<li><a href="/threejs/lessons/kr/threejs-custom-geometry.html">사용자 지정 Geometry</a></li>
<li><a href="/threejs/lessons/kr/threejs-custom-buffergeometry.html">사용자 지정 BufferGeometry</a></li>
        </ul>
  <li>팁</li>
        <ul>
          <li><a href="/threejs/lessons/kr/threejs-rendering-on-demand.html">불필요한 렌더링 없애기</a></li>
<li><a href="/threejs/lessons/kr/threejs-debugging-javascript.html">자바스크립트 디버깅</a></li>
<li><a href="/threejs/lessons/kr/threejs-debugging-glsl.html">GLSL 디버깅</a></li>
<li><a href="/threejs/lessons/kr/threejs-tips.html#screenshot">스크린샷 찍기</a></li>
<li><a href="/threejs/lessons/kr/threejs-tips.html#preservedrawingbuffer">캔버스 초기화 방지하기</a></li>
<li><a href="/threejs/lessons/kr/threejs-tips.html#tabindex">캔버스에서 키 입력 받기</a></li>
<li><a href="/threejs/lessons/kr/threejs-tips.html#transparent-canvas">캔버스를 투명하게 만들기</a></li>
<li><a href="/threejs/lessons/kr/threejs-tips.html#html-background">Three.js를 HTML 요소의 배경으로 사용하기</a></li>
        </ul>
  <li>최적화하기</li>
        <ul>
          <li><a href="/threejs/lessons/kr/threejs-optimize-lots-of-objects.html">요소가 많을 때 최적화하는 방법</a></li>
<li><a href="/threejs/lessons/kr/threejs-optimize-lots-of-objects-animated.html">애니메이션 요소가 많을 때 최적화하는 방법</a></li>
<li><a href="/threejs/lessons/kr/threejs-offscreencanvas.html">웹 워커에서 OffscreenCanvas 사용하기</a></li>
        </ul>
  <li>활용하기</li>
        <ul>
          <li><a href="/threejs/lessons/kr/threejs-load-obj.html">.OBJ 파일 불러오기</a></li>
<li><a href="/threejs/lessons/kr/threejs-load-gltf.html">.GLTF 파일 불러오기</a></li>
<li><a href="/threejs/lessons/kr/threejs-backgrounds.html">배경, 하늘 상자 추가하기</a></li>
<li><a href="/threejs/lessons/kr/threejs-transparency.html">물체의 투명도 설정하기</a></li>
<li><a href="/threejs/lessons/kr/threejs-multiple-scenes.html">다중 캔버스, 다중 장면 만들기</a></li>
<li><a href="/threejs/lessons/kr/threejs-picking.html">물체를 마우스로 피킹하기</a></li>
<li><a href="/threejs/lessons/kr/threejs-post-processing.html">후처리</a></li>
<li><a href="/threejs/lessons/kr/threejs-post-processing-3dlut.html">LUT 파일로 후처리 효과 적용하기</a></li>
<li><a href="/threejs/lessons/kr/threejs-shadertoy.html">쉐이더토이 쉐이더 활용하기</a></li>
<li><a href="/threejs/lessons/kr/threejs-align-html-elements-to-3d.html">HTML 요소를 3D로 정렬하기</a></li>
<li><a href="/threejs/lessons/kr/threejs-indexed-textures.html">피킹과 색상에 인덱스 텍스처 사용하기</a></li>
<li><a href="/threejs/lessons/kr/threejs-canvas-textures.html">캔버스로 동적 텍스처 만들기</a></li>
<li><a href="/threejs/lessons/kr/threejs-billboards.html">빌보드와 파사드</a></li>
<li><a href="/threejs/lessons/kr/threejs-cleanup.html">메모리 해제하기</a></li>
<li><a href="/threejs/lessons/kr/threejs-voxel-geometry.html">복셀 Geometry(마인크래프트) 만들기</a></li>
<li><a href="/threejs/lessons/kr/threejs-game.html">게임 만들기</a></li>
        </ul>
  <li>웹VR</li>
        <ul>
          <li><a href="/threejs/lessons/kr/threejs-webvr.html">VR - Basics</a></li>
<li><a href="/threejs/lessons/kr/threejs-webvr-look-to-select.html">VR - Look To Select</a></li>
<li><a href="/threejs/lessons/kr/threejs-webvr-point-to-select.html">VR - Point To Select</a></li>
        </ul>
  <li>레퍼런스</li>
        <ul>
          <li><a href="/threejs/lessons/kr/threejs-material-table.html">재질(Material) 속성표</a></li>
        </ul></ul>
<ul>
  <li>바로가기</li>
  <ul>
    <li><a href="https://github.com/gfxfundamentals/threejsfundamentals">Github</a></li>
    <li><a href="https://threejs.org">Three.js</a></li>
    <li><a href="https://threejs.org/docs/">Three.js docs</a></li>
  </ul>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        
    <div>
      <a href="http://stackoverflow.com/questions/tagged/three.js">Stackoverflow</a>
      /
      <a href="http://github.com/greggman/threefundamentals/issues">Github</a>
    </div>
  

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'threejsfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'Three.js의 조명';
            var disqus_title = 'Three.js의 조명';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("threejsfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/threejs/lessons/resources/prettify.js"></script>
<script src="/threejs/lessons/resources/lesson.js"></script>
<script>
(function() {
  if (window.location.hostname.indexOf("threejsfundamentals.org") < 0) {
      return;
  }

  function addScript(src, fn) {
    const script = document.createElement('script');
    const firstScript = document.getElementsByTagName('script')[0];
    script.async = true;
    script.defer = true;
    if (fn) {
      script.addEventListener('load', fn);
    }
    script.src = src;
    firstScript.parentNode.insertBefore(script, firstScript);
  }

  addScript('//cdn.webglstats.com/stat.js');
  addScript('https://www.googletagmanager.com/gtag/js?id=UA-120733518-1', () => {
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-120733518-1');
  });
}());
</script>


</html>



